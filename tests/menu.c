/* menu.c generated by valac 0.24.0, the Vala compiler
 * generated from menu.vala, do not modify */

/* -- to compile
valac  --pkg gio-2.0  --pkg posix  --pkg gtk+-3.0  \
    menu.vala  -o /tmp/menutest
*/
/* -- to test class
static int main (string[] args) {
    Gtk.init (ref args);
    new Xcls_WindowLeftTree();
    WindowLeftTree.show_all();
     Gtk.main ();
    return 0;
}
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>


#define TYPE_XCLS_WINDOW (xcls_window_get_type ())
#define XCLS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_XCLS_WINDOW, Xcls_Window))
#define XCLS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_XCLS_WINDOW, Xcls_WindowClass))
#define IS_XCLS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_XCLS_WINDOW))
#define IS_XCLS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_XCLS_WINDOW))
#define XCLS_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_XCLS_WINDOW, Xcls_WindowClass))

typedef struct _Xcls_Window Xcls_Window;
typedef struct _Xcls_WindowClass Xcls_WindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Xcls_WindowPrivate Xcls_WindowPrivate;
typedef struct _Block1Data Block1Data;

#define XCLS_WINDOW_TYPE_XCLS_MENUITEM7 (xcls_window_xcls_menuitem7_get_type ())
#define XCLS_WINDOW_XCLS_MENUITEM7(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XCLS_WINDOW_TYPE_XCLS_MENUITEM7, Xcls_WindowXcls_MenuItem7))
#define XCLS_WINDOW_XCLS_MENUITEM7_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XCLS_WINDOW_TYPE_XCLS_MENUITEM7, Xcls_WindowXcls_MenuItem7Class))
#define XCLS_WINDOW_IS_XCLS_MENUITEM7(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XCLS_WINDOW_TYPE_XCLS_MENUITEM7))
#define XCLS_WINDOW_IS_XCLS_MENUITEM7_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XCLS_WINDOW_TYPE_XCLS_MENUITEM7))
#define XCLS_WINDOW_XCLS_MENUITEM7_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XCLS_WINDOW_TYPE_XCLS_MENUITEM7, Xcls_WindowXcls_MenuItem7Class))

typedef struct _Xcls_WindowXcls_MenuItem7 Xcls_WindowXcls_MenuItem7;
typedef struct _Xcls_WindowXcls_MenuItem7Class Xcls_WindowXcls_MenuItem7Class;
typedef struct _Xcls_WindowXcls_MenuItem7Private Xcls_WindowXcls_MenuItem7Private;

struct _Xcls_Window {
	GObject parent_instance;
	Xcls_WindowPrivate * priv;
};

struct _Xcls_WindowClass {
	GObjectClass parent_class;
};

struct _Block1Data {
	int _ref_count_;
	Xcls_Window* self;
	GtkMenu* leftmenu;
};

struct _Xcls_WindowXcls_MenuItem7 {
	GObject parent_instance;
	Xcls_WindowXcls_MenuItem7Private * priv;
	GtkMenuItem* el;
	Xcls_Window* _this;
};

struct _Xcls_WindowXcls_MenuItem7Class {
	GObjectClass parent_class;
};


static gpointer xcls_window_parent_class = NULL;
static gpointer xcls_window_xcls_menuitem7_parent_class = NULL;

gint _vala_main (gchar** args, int args_length1);
Xcls_Window* xcls_window_new (void);
Xcls_Window* xcls_window_construct (GType object_type);
GType xcls_window_get_type (void) G_GNUC_CONST;
enum  {
	XCLS_WINDOW_DUMMY_PROPERTY
};
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda3_ (Block1Data* _data1_, GdkEventButton* ev);
static gboolean ___lambda3__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
GType xcls_window_xcls_menuitem7_get_type (void) G_GNUC_CONST;
Xcls_WindowXcls_MenuItem7* xcls_window_xcls_menuitem7_new (void);
Xcls_WindowXcls_MenuItem7* xcls_window_xcls_menuitem7_construct (GType object_type);
void xcls_window_xcls_menuitem7_init (Xcls_WindowXcls_MenuItem7* self, Xcls_Window* _owner);
enum  {
	XCLS_WINDOW_XCLS_MENUITEM7_DUMMY_PROPERTY
};
static void __lambda4_ (Xcls_WindowXcls_MenuItem7* self);
static void ___lambda4__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static void xcls_window_xcls_menuitem7_finalize (GObject* obj);


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	Xcls_Window* _tmp0_ = NULL;
	Xcls_Window* _tmp1_ = NULL;
	gtk_init (&args_length1, &args);
	g_log_set_always_fatal (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL);
	_tmp0_ = xcls_window_new ();
	_tmp1_ = _tmp0_;
	_g_object_unref0 (_tmp1_);
	gtk_main ();
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Xcls_Window* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->leftmenu);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda3_ (Block1Data* _data1_, GdkEventButton* ev) {
	Xcls_Window* self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GdkEventButton* _tmp1_ = NULL;
	GdkEventType _tmp2_ = 0;
	GdkEventButton* _tmp5_ = NULL;
	guint _tmp6_ = 0U;
	GdkEventButton* _tmp7_ = NULL;
	guint32 _tmp8_ = 0U;
	self = _data1_->self;
	g_return_val_if_fail (ev != NULL, FALSE);
	_tmp1_ = ev;
	_tmp2_ = _tmp1_->type;
	if (_tmp2_ != GDK_BUTTON_PRESS) {
		_tmp0_ = TRUE;
	} else {
		GdkEventButton* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		_tmp3_ = ev;
		_tmp4_ = _tmp3_->button;
		_tmp0_ = _tmp4_ != ((guint) 3);
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp5_ = ev;
	_tmp6_ = _tmp5_->button;
	_tmp7_ = ev;
	_tmp8_ = _tmp7_->time;
	gtk_menu_popup (_data1_->leftmenu, NULL, NULL, NULL, NULL, _tmp6_, _tmp8_);
	result = TRUE;
	return result;
}


static gboolean ___lambda3__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda3_ (self, event);
	return result;
}


Xcls_Window* xcls_window_construct (GType object_type) {
	Xcls_Window * self = NULL;
	Block1Data* _data1_;
	GtkWindow* w = NULL;
	GtkWindow* _tmp0_ = NULL;
	GtkButton* b = NULL;
	GtkButton* _tmp1_ = NULL;
	GtkMenu* _tmp2_ = NULL;
	Xcls_WindowXcls_MenuItem7* child_0 = NULL;
	Xcls_WindowXcls_MenuItem7* _tmp3_ = NULL;
	GtkMenuItem* _tmp4_ = NULL;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (Xcls_Window*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp0_);
	w = _tmp0_;
	_tmp1_ = (GtkButton*) gtk_button_new_with_label ("Click me (0)");
	g_object_ref_sink (_tmp1_);
	b = _tmp1_;
	gtk_container_add ((GtkContainer*) w, (GtkWidget*) b);
	_tmp2_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp2_);
	_data1_->leftmenu = _tmp2_;
	g_signal_connect_data ((GtkWidget*) b, "button-press-event", (GCallback) ___lambda3__gtk_widget_button_press_event, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp3_ = xcls_window_xcls_menuitem7_new ();
	child_0 = _tmp3_;
	xcls_window_xcls_menuitem7_init (child_0, self);
	_tmp4_ = child_0->el;
	gtk_menu_shell_append ((GtkMenuShell*) _data1_->leftmenu, (GtkWidget*) _tmp4_);
	gtk_widget_show_all ((GtkWidget*) _data1_->leftmenu);
	gtk_widget_show_all ((GtkWidget*) w);
	_g_object_unref0 (child_0);
	_g_object_unref0 (b);
	_g_object_unref0 (w);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


Xcls_Window* xcls_window_new (void) {
	return xcls_window_construct (TYPE_XCLS_WINDOW);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda4_ (Xcls_WindowXcls_MenuItem7* self) {
	g_print ("SELECT?");
	return;
}


static void ___lambda4__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	__lambda4_ ((Xcls_WindowXcls_MenuItem7*) self);
}


void xcls_window_xcls_menuitem7_init (Xcls_WindowXcls_MenuItem7* self, Xcls_Window* _owner) {
	Xcls_Window* _tmp0_ = NULL;
	Xcls_Window* _tmp1_ = NULL;
	GtkMenuItem* el = NULL;
	GtkMenuItem* _tmp2_ = NULL;
	GtkMenuItem* _tmp3_ = NULL;
	GtkMenuItem* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (_owner != NULL);
	_tmp0_ = _owner;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->_this);
	self->_this = _tmp1_;
	_tmp2_ = (GtkMenuItem*) gtk_menu_item_new_with_label ("Delete Element");
	g_object_ref_sink (_tmp2_);
	el = _tmp2_;
	_tmp3_ = _g_object_ref0 (el);
	_g_object_unref0 (self->el);
	self->el = _tmp3_;
	g_print ("add activate\n");
	_tmp4_ = self->el;
	g_signal_connect_object (_tmp4_, "activate", (GCallback) ___lambda4__gtk_menu_item_activate, self, 0);
	_g_object_unref0 (el);
}


Xcls_WindowXcls_MenuItem7* xcls_window_xcls_menuitem7_construct (GType object_type) {
	Xcls_WindowXcls_MenuItem7 * self = NULL;
	self = (Xcls_WindowXcls_MenuItem7*) g_object_new (object_type, NULL);
	return self;
}


Xcls_WindowXcls_MenuItem7* xcls_window_xcls_menuitem7_new (void) {
	return xcls_window_xcls_menuitem7_construct (XCLS_WINDOW_TYPE_XCLS_MENUITEM7);
}


static void xcls_window_xcls_menuitem7_class_init (Xcls_WindowXcls_MenuItem7Class * klass) {
	xcls_window_xcls_menuitem7_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = xcls_window_xcls_menuitem7_finalize;
}


static void xcls_window_xcls_menuitem7_instance_init (Xcls_WindowXcls_MenuItem7 * self) {
}


static void xcls_window_xcls_menuitem7_finalize (GObject* obj) {
	Xcls_WindowXcls_MenuItem7 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, XCLS_WINDOW_TYPE_XCLS_MENUITEM7, Xcls_WindowXcls_MenuItem7);
	_g_object_unref0 (self->el);
	_g_object_unref0 (self->_this);
	G_OBJECT_CLASS (xcls_window_xcls_menuitem7_parent_class)->finalize (obj);
}


GType xcls_window_xcls_menuitem7_get_type (void) {
	static volatile gsize xcls_window_xcls_menuitem7_type_id__volatile = 0;
	if (g_once_init_enter (&xcls_window_xcls_menuitem7_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Xcls_WindowXcls_MenuItem7Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xcls_window_xcls_menuitem7_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Xcls_WindowXcls_MenuItem7), 0, (GInstanceInitFunc) xcls_window_xcls_menuitem7_instance_init, NULL };
		GType xcls_window_xcls_menuitem7_type_id;
		xcls_window_xcls_menuitem7_type_id = g_type_register_static (G_TYPE_OBJECT, "Xcls_WindowXcls_MenuItem7", &g_define_type_info, 0);
		g_once_init_leave (&xcls_window_xcls_menuitem7_type_id__volatile, xcls_window_xcls_menuitem7_type_id);
	}
	return xcls_window_xcls_menuitem7_type_id__volatile;
}


static void xcls_window_class_init (Xcls_WindowClass * klass) {
	xcls_window_parent_class = g_type_class_peek_parent (klass);
}


static void xcls_window_instance_init (Xcls_Window * self) {
}


GType xcls_window_get_type (void) {
	static volatile gsize xcls_window_type_id__volatile = 0;
	if (g_once_init_enter (&xcls_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Xcls_WindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xcls_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Xcls_Window), 0, (GInstanceInitFunc) xcls_window_instance_init, NULL };
		GType xcls_window_type_id;
		xcls_window_type_id = g_type_register_static (G_TYPE_OBJECT, "Xcls_Window", &g_define_type_info, 0);
		g_once_init_leave (&xcls_window_type_id__volatile, xcls_window_type_id);
	}
	return xcls_window_type_id__volatile;
}



