/* Gtk.vala.c generated by valac 0.24.0, the Vala compiler
 * generated from Gtk.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <json-glib/json-glib.h>


#define JS_RENDER_TYPE_JS_RENDER (js_render_js_render_get_type ())
#define JS_RENDER_JS_RENDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JS_RENDER_TYPE_JS_RENDER, JsRenderJsRender))
#define JS_RENDER_JS_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JS_RENDER_TYPE_JS_RENDER, JsRenderJsRenderClass))
#define JS_RENDER_IS_JS_RENDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JS_RENDER_TYPE_JS_RENDER))
#define JS_RENDER_IS_JS_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JS_RENDER_TYPE_JS_RENDER))
#define JS_RENDER_JS_RENDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JS_RENDER_TYPE_JS_RENDER, JsRenderJsRenderClass))

typedef struct _JsRenderJsRender JsRenderJsRender;
typedef struct _JsRenderJsRenderClass JsRenderJsRenderClass;
typedef struct _JsRenderJsRenderPrivate JsRenderJsRenderPrivate;

#define PROJECT_TYPE_PROJECT (project_project_get_type ())
#define PROJECT_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PROJECT_TYPE_PROJECT, ProjectProject))
#define PROJECT_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PROJECT_TYPE_PROJECT, ProjectProjectClass))
#define PROJECT_IS_PROJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PROJECT_TYPE_PROJECT))
#define PROJECT_IS_PROJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PROJECT_TYPE_PROJECT))
#define PROJECT_PROJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PROJECT_TYPE_PROJECT, ProjectProjectClass))

typedef struct _ProjectProject ProjectProject;
typedef struct _ProjectProjectClass ProjectProjectClass;

#define JS_RENDER_TYPE_NODE (js_render_node_get_type ())
#define JS_RENDER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JS_RENDER_TYPE_NODE, JsRenderNode))
#define JS_RENDER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JS_RENDER_TYPE_NODE, JsRenderNodeClass))
#define JS_RENDER_IS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JS_RENDER_TYPE_NODE))
#define JS_RENDER_IS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JS_RENDER_TYPE_NODE))
#define JS_RENDER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JS_RENDER_TYPE_NODE, JsRenderNodeClass))

typedef struct _JsRenderNode JsRenderNode;
typedef struct _JsRenderNodeClass JsRenderNodeClass;

#define JS_RENDER_TYPE_GTK (js_render_gtk_get_type ())
#define JS_RENDER_GTK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JS_RENDER_TYPE_GTK, JsRenderGtk))
#define JS_RENDER_GTK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JS_RENDER_TYPE_GTK, JsRenderGtkClass))
#define JS_RENDER_IS_GTK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JS_RENDER_TYPE_GTK))
#define JS_RENDER_IS_GTK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JS_RENDER_TYPE_GTK))
#define JS_RENDER_GTK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JS_RENDER_TYPE_GTK, JsRenderGtkClass))

typedef struct _JsRenderGtk JsRenderGtk;
typedef struct _JsRenderGtkClass JsRenderGtkClass;
typedef struct _JsRenderGtkPrivate JsRenderGtkPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define _js_render_node_unref0(var) ((var == NULL) ? NULL : (var = (js_render_node_unref (var), NULL)))
#define _json_object_unref0(var) ((var == NULL) ? NULL : (var = (json_object_unref (var), NULL)))
#define _json_array_unref0(var) ((var == NULL) ? NULL : (var = (json_array_unref (var), NULL)))

struct _JsRenderJsRender {
	GObject parent_instance;
	JsRenderJsRenderPrivate * priv;
	GList* doubleStringProps;
	gchar* id;
	gchar* name;
	gchar* fullname;
	gchar* path;
	gchar* parent;
	gchar* title;
	gchar* permname;
	gchar* modOrder;
	gchar* xtype;
	ProjectProject* project;
	JsRenderNode* tree;
	GList* cn;
	gboolean hasParent;
};

struct _JsRenderJsRenderClass {
	GObjectClass parent_class;
};

struct _JsRenderGtk {
	JsRenderJsRender parent_instance;
	JsRenderGtkPrivate * priv;
};

struct _JsRenderGtkClass {
	JsRenderJsRenderClass parent_class;
};

struct _JsRenderGtkPrivate {
	GeeHashMap* ctors;
};

typedef enum  {
	JS_RENDER_ERROR_INVALID_FORMAT
} JsRenderError;
#define JS_RENDER_ERROR js_render_error_quark ()

extern gint js_render_gid;
gint js_render_gid = 1;
static gpointer js_render_gtk_parent_class = NULL;

GType js_render_js_render_get_type (void) G_GNUC_CONST;
gpointer project_project_ref (gpointer instance);
void project_project_unref (gpointer instance);
GParamSpec* project_param_spec_project (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void project_value_set_project (GValue* value, gpointer v_object);
void project_value_take_project (GValue* value, gpointer v_object);
gpointer project_value_get_project (const GValue* value);
GType project_project_get_type (void) G_GNUC_CONST;
gpointer js_render_node_ref (gpointer instance);
void js_render_node_unref (gpointer instance);
GParamSpec* js_render_param_spec_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void js_render_value_set_node (GValue* value, gpointer v_object);
void js_render_value_take_node (GValue* value, gpointer v_object);
gpointer js_render_value_get_node (const GValue* value);
GType js_render_node_get_type (void) G_GNUC_CONST;
GType js_render_gtk_get_type (void) G_GNUC_CONST;
#define JS_RENDER_GTK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), JS_RENDER_TYPE_GTK, JsRenderGtkPrivate))
enum  {
	JS_RENDER_GTK_DUMMY_PROPERTY
};
JsRenderGtk* js_render_gtk_new (ProjectProject* project, const gchar* path);
JsRenderGtk* js_render_gtk_construct (GType object_type, ProjectProject* project, const gchar* path);
JsRenderJsRender* js_render_js_render_new (ProjectProject* project, const gchar* path);
JsRenderJsRender* js_render_js_render_construct (GType object_type, ProjectProject* project, const gchar* path);
GQuark js_render_error_quark (void);
void js_render_gtk_loadItems (JsRenderGtk* self, GError** error);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);
static void _vala_JsonNode_free (JsonNode* self);
JsRenderNode* js_render_node_new (void);
JsRenderNode* js_render_node_construct (GType object_type);
void js_render_node_loadFromJson (JsRenderNode* self, JsonObject* obj);
static void js_render_gtk_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


JsRenderGtk* js_render_gtk_construct (GType object_type, ProjectProject* project, const gchar* path) {
	JsRenderGtk * self = NULL;
	gchar* _tmp0_ = NULL;
	ProjectProject* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	gchar** cc = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar** _tmp10_ = NULL;
	gint cc_length1 = 0;
	gint _cc_size_ = 0;
	GeeHashMap* _tmp11_ = NULL;
	g_return_val_if_fail (project != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = g_strdup ("Gtk");
	_g_free0 (((JsRenderJsRender*) self)->xtype);
	((JsRenderJsRender*) self)->xtype = _tmp0_;
	_tmp1_ = project;
	_tmp2_ = path;
	self = (JsRenderGtk*) js_render_js_render_construct (object_type, _tmp1_, _tmp2_);
	_tmp3_ = js_render_gid;
	js_render_gid = _tmp3_ + 1;
	_tmp4_ = g_strdup_printf ("file-gtk-%d", _tmp3_);
	_g_free0 (((JsRenderJsRender*) self)->id);
	((JsRenderJsRender*) self)->id = _tmp4_;
	_tmp5_ = g_strdup ("Gtk.MessageDialog=parent:null|flags:Gtk.DialogFlags.MODAL|message_type" \
"|buttons|text");
	_tmp6_ = g_strdup ("Gtk.ToolButton=icon_widget:null|label:null");
	_tmp7_ = g_strdup ("Gtk.ScrolledWindow=hadjustment:null|vadjustment:null");
	_tmp8_ = g_strdup ("Gtk.SourceBuffer=table:null");
	_tmp9_ = g_strdup ("Gtk.VBox=homogeneous:true|spacing:0");
	_tmp10_ = g_new0 (gchar*, 5 + 1);
	_tmp10_[0] = _tmp5_;
	_tmp10_[1] = _tmp6_;
	_tmp10_[2] = _tmp7_;
	_tmp10_[3] = _tmp8_;
	_tmp10_[4] = _tmp9_;
	cc = _tmp10_;
	cc_length1 = 5;
	_cc_size_ = cc_length1;
	_tmp11_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->ctors);
	self->priv->ctors = _tmp11_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				gint _tmp14_ = 0;
				gchar** _tmp15_ = NULL;
				gint _tmp15__length1 = 0;
				gchar** ar = NULL;
				gchar** _tmp16_ = NULL;
				gint _tmp16__length1 = 0;
				gint _tmp17_ = 0;
				const gchar* _tmp18_ = NULL;
				gchar** _tmp19_ = NULL;
				gchar** _tmp20_ = NULL;
				gint ar_length1 = 0;
				gint _ar_size_ = 0;
				GeeHashMap* _tmp21_ = NULL;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				const gchar* _tmp23_ = NULL;
				gchar** _tmp24_ = NULL;
				gint _tmp24__length1 = 0;
				const gchar* _tmp25_ = NULL;
				if (!_tmp12_) {
					gint _tmp13_ = 0;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = cc;
				_tmp15__length1 = cc_length1;
				if (!(_tmp14_ < _tmp15__length1)) {
					break;
				}
				_tmp16_ = cc;
				_tmp16__length1 = cc_length1;
				_tmp17_ = i;
				_tmp18_ = _tmp16_[_tmp17_];
				_tmp20_ = _tmp19_ = g_strsplit (_tmp18_, "=", 0);
				ar = _tmp20_;
				ar_length1 = _vala_array_length (_tmp19_);
				_ar_size_ = ar_length1;
				_tmp21_ = self->priv->ctors;
				_tmp22_ = ar;
				_tmp22__length1 = ar_length1;
				_tmp23_ = _tmp22_[0];
				_tmp24_ = ar;
				_tmp24__length1 = ar_length1;
				_tmp25_ = _tmp24_[1];
				gee_abstract_map_set ((GeeAbstractMap*) _tmp21_, _tmp23_, _tmp25_);
				ar = (_vala_array_free (ar, ar_length1, (GDestroyNotify) g_free), NULL);
			}
		}
	}
	cc = (_vala_array_free (cc, cc_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


JsRenderGtk* js_render_gtk_new (ProjectProject* project, const gchar* path) {
	return js_render_gtk_construct (JS_RENDER_TYPE_GTK, project, path);
}


static JsonNode* _vala_JsonNode_copy (JsonNode* self) {
	return g_boxed_copy (json_node_get_type (), self);
}


static gpointer __vala_JsonNode_copy0 (gpointer self) {
	return self ? _vala_JsonNode_copy (self) : NULL;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static gpointer _json_object_ref0 (gpointer self) {
	return self ? json_object_ref (self) : NULL;
}


static gpointer _json_array_ref0 (gpointer self) {
	return self ? json_array_ref (self) : NULL;
}


void js_render_gtk_loadItems (JsRenderGtk* self, GError** error) {
	JsRenderNode* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	JsonParser* pa = NULL;
	JsonParser* _tmp4_ = NULL;
	JsonParser* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	JsonNode* node = NULL;
	JsonParser* _tmp7_ = NULL;
	JsonNode* _tmp8_ = NULL;
	JsonNode* _tmp9_ = NULL;
	JsonNode* _tmp10_ = NULL;
	JsonNodeType _tmp11_ = 0;
	JsonObject* obj = NULL;
	JsonNode* _tmp15_ = NULL;
	JsonObject* _tmp16_ = NULL;
	JsonObject* _tmp17_ = NULL;
	JsonObject* _tmp18_ = NULL;
	const gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	JsonObject* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	gchar* _tmp23_ = NULL;
	JsonObject* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	JsonArray* ar = NULL;
	JsonObject* _tmp27_ = NULL;
	JsonArray* _tmp28_ = NULL;
	JsonArray* _tmp29_ = NULL;
	JsonObject* tree_base = NULL;
	JsonArray* _tmp30_ = NULL;
	JsonObject* _tmp31_ = NULL;
	JsonObject* _tmp32_ = NULL;
	JsRenderNode* _tmp33_ = NULL;
	JsRenderNode* _tmp34_ = NULL;
	JsonObject* _tmp35_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_print ("load Items!");
	_tmp0_ = ((JsRenderJsRender*) self)->tree;
	if (_tmp0_ != NULL) {
		return;
	}
	_tmp1_ = ((JsRenderJsRender*) self)->path;
	_tmp2_ = g_strconcat ("load: ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	g_print ("%s", _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = json_parser_new ();
	pa = _tmp4_;
	_tmp5_ = pa;
	_tmp6_ = ((JsRenderJsRender*) self)->path;
	json_parser_load_from_file (_tmp5_, _tmp6_, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == JS_RENDER_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (pa);
			return;
		} else {
			_g_object_unref0 (pa);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp7_ = pa;
	_tmp8_ = json_parser_get_root (_tmp7_);
	_tmp9_ = __vala_JsonNode_copy0 (_tmp8_);
	node = _tmp9_;
	_tmp10_ = node;
	_tmp11_ = json_node_get_node_type (_tmp10_);
	if (_tmp11_ != JSON_NODE_OBJECT) {
		JsonNode* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		GError* _tmp14_ = NULL;
		_tmp12_ = node;
		_tmp13_ = json_node_type_name (_tmp12_);
		_tmp14_ = g_error_new (JS_RENDER_ERROR, JS_RENDER_ERROR_INVALID_FORMAT, "Unexpected element type %s", _tmp13_);
		_inner_error_ = _tmp14_;
		if (_inner_error_->domain == JS_RENDER_ERROR) {
			g_propagate_error (error, _inner_error_);
			__vala_JsonNode_free0 (node);
			_g_object_unref0 (pa);
			return;
		} else {
			__vala_JsonNode_free0 (node);
			_g_object_unref0 (pa);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp15_ = node;
	_tmp16_ = json_node_get_object (_tmp15_);
	_tmp17_ = _json_object_ref0 (_tmp16_);
	obj = _tmp17_;
	_tmp18_ = obj;
	_tmp19_ = json_object_get_string_member (_tmp18_, "name");
	_tmp20_ = g_strdup (_tmp19_);
	_g_free0 (((JsRenderJsRender*) self)->name);
	((JsRenderJsRender*) self)->name = _tmp20_;
	_tmp21_ = obj;
	_tmp22_ = json_object_get_string_member (_tmp21_, "parent");
	_tmp23_ = g_strdup (_tmp22_);
	_g_free0 (((JsRenderJsRender*) self)->parent);
	((JsRenderJsRender*) self)->parent = _tmp23_;
	_tmp24_ = obj;
	_tmp25_ = json_object_get_string_member (_tmp24_, "title");
	_tmp26_ = g_strdup (_tmp25_);
	_g_free0 (((JsRenderJsRender*) self)->title);
	((JsRenderJsRender*) self)->title = _tmp26_;
	_tmp27_ = obj;
	_tmp28_ = json_object_get_array_member (_tmp27_, "items");
	_tmp29_ = _json_array_ref0 (_tmp28_);
	ar = _tmp29_;
	_tmp30_ = ar;
	_tmp31_ = json_array_get_object_element (_tmp30_, (guint) 1);
	_tmp32_ = _json_object_ref0 (_tmp31_);
	tree_base = _tmp32_;
	_tmp33_ = js_render_node_new ();
	_js_render_node_unref0 (((JsRenderJsRender*) self)->tree);
	((JsRenderJsRender*) self)->tree = _tmp33_;
	_tmp34_ = ((JsRenderJsRender*) self)->tree;
	_tmp35_ = tree_base;
	js_render_node_loadFromJson (_tmp34_, _tmp35_);
	_json_object_unref0 (tree_base);
	_json_array_unref0 (ar);
	_json_object_unref0 (obj);
	__vala_JsonNode_free0 (node);
	_g_object_unref0 (pa);
}


static void js_render_gtk_class_init (JsRenderGtkClass * klass) {
	js_render_gtk_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (JsRenderGtkPrivate));
	G_OBJECT_CLASS (klass)->finalize = js_render_gtk_finalize;
}


static void js_render_gtk_instance_init (JsRenderGtk * self) {
	self->priv = JS_RENDER_GTK_GET_PRIVATE (self);
}


static void js_render_gtk_finalize (GObject* obj) {
	JsRenderGtk * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, JS_RENDER_TYPE_GTK, JsRenderGtk);
	_g_object_unref0 (self->priv->ctors);
	G_OBJECT_CLASS (js_render_gtk_parent_class)->finalize (obj);
}


GType js_render_gtk_get_type (void) {
	static volatile gsize js_render_gtk_type_id__volatile = 0;
	if (g_once_init_enter (&js_render_gtk_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (JsRenderGtkClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) js_render_gtk_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (JsRenderGtk), 0, (GInstanceInitFunc) js_render_gtk_instance_init, NULL };
		GType js_render_gtk_type_id;
		js_render_gtk_type_id = g_type_register_static (JS_RENDER_TYPE_JS_RENDER, "JsRenderGtk", &g_define_type_info, 0);
		g_once_init_leave (&js_render_gtk_type_id__volatile, js_render_gtk_type_id);
	}
	return js_render_gtk_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



