{
    "id": "file-gtk-11",
    "name": "WindowLeftTree",
    "parent": "",
    "title": false,
    "path": "/home/alan/gitlive/app.Builder.js/Builder4/WindowLeftTree.bjs",
    "items": [
        {
            "|getActiveFile": "LeftTree",
            "pack": "add",
            "xtype": "ScrolledWindow",
            "|JsRender.Node?:getActiveElement": " () { // return path to actie node.\n\n     var path = this.getActivePath();\n     if (path.length < 1) {\n        return null;\n     }\n     Gtk.TreeIter   iter = new ();\n     _this.model.el.get_iter_from_string(out iter, path);\n     \n     GLib.Value value;\n     _this.model.el.get_value(iter, 2, out value);\n     \n     return (JsRender.Node)value;\n}\n",
            "|JsRender.JsRender:getActiveFile": "() {\n    return this.model.file;\n}\n",
            "|string:getActivePath": " () {\n    var model = this.model;\n    var view = this.view;\n    if (view.el.get_selection().count_selected_rows() < 1) {\n        return \"\";\n    }\n    Gtk.TreeIter iter;\n    GtkStore mod;\n    view.selection.get_selected(out mod, out iter);\n    return mod.get_path(iter).to_string();\n}\n",
            "|Palete.Palete:getPaleteProvider": "function() {\n\n    //var pm = imports.Builder.Provider.ProjectManager.ProjectManager;\n    return _this.model.file.getPalete();\n\n}\n",
            "|void:getRenderer": "() {\n\n    /*\n    switch( this.getActiveFile().getType()) {\n        case 'Roo':\n            return this.get('/RightBrowser.view');\n        case 'Gtk':\n            return this.get('/RightGtkView');\n    }\n    */\n\n}\n",
            "|init": " this.el.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)\n \n",
            "|void:renderView": "() {\n    \n    _this.model.file.renderJS();\n\n}\n",
            "|shadow_type": "Gtk.ShadowType.IN",
            "|xns": "Gtk",
            "items": [
                {
                    "listeners": {
                        "button_press_event": "  ( ev) {\n    //console.log(\"button press?\");\n\n    if (!_this.model.file.editorSave()) {\n    \n        // popup!! - click handled.. \n        return;\n    }\n\n    if (ev.type != Gdk.EventType.BUTTON_PRESS  || ev.button.button != 3) {\n        //print(\"click\" + ev.type);\n        return;\n    }\n    Gtk.TreePath res;\n    _this.view.el.get_path_at_pos(ev.button.x,ev.button.y, out res);\n        \n      //if (!this.get('/LeftTreeMenu').el)  { \n      //      this.get('/LeftTreeMenu').init(); \n      //  }\n        \n     _this.LeftTreeMenu.el.set_screen(Gdk.Screen.get_default());\n     _this.LeftTreeMenu.el.show_all();\n      _this.LeftTreeMenu.el.popup(null, null, null, null, 3, ev.button.time);\n     //   print(\"click:\" + res.path.to_string());\n     //   return false;\n}",
                        "drag_begin": "( ctx)  => {\n\t//print('SOURCE: drag-begin');\n        \n        \n        this.targetData = \"\";\n        \n        // find what is selected in our tree...\n        Gtk.TreeIter iter;\n        var s = this.model.get_selection();\n        Gtk.TreeStore mod;\n        s.get_selected(out mod, out iter);\n\n        // set some properties of the tree for use by the dropped element.\n        GLib.Value value;\n        _this.model.el.get_value(iter, 2, out value);\n        var data = (JsRender.Node)(value.value);\n        var xname = data.fqn();\n        \n        this.dragData = xname;\n        this.dropList = this.file.getPalete().getDropList(xname);\n        \n\n        // make the drag icon a picture of the node that was selected\n        var path = _this.model.el.get_path(iter);\n\n        this.treepath = path.to_string();\n        \n        var pix = this.el.create_row_drag_icon ( path);\n        \n        Gtk.drag_set_icon_surface (ctx, pix) \n        \n        return true;\n}",
                        "drag_end": "function (drag_context) {\n\t//Seed.print('LEFT-TREE: drag-end');\n        this.dragData = \"\";\n        this.dropList = null;\n        this.targetData = \"\";\n        this.view.highlight(false);\n//        return true;\n}",
                        "drag_motion": " ( ctx, x, y, time)  => {\n     //console.log(\"LEFT-TREE: drag-motion\");\n        var src = Gtk.drag_get_source_widget(ctx);\n        \n        // a drag from  elsewhere...- prevent drop..\n        if (src != this.el) {\n            //print(\"no drag data!\");\n            Gdk.drag_status(ctx, 0, time);\n            this.targetData = \"\";\n            return true;\n        }\n        \n        \n        var action = Gdk.DragAction.COPY;\n        if (src == this.el) {\n            // unless we are copying!!! ctl button..\n            action = ctx.actions & Gdk.DragAction.MOVE ? Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;\n        }\n        var data = {};\n\n        if (this.model.el.iter_n_children(null) < 1) {\n\t        // no children.. -- asume it's ok..\n\t        \n\t        this.targetData =  [ '' , Gtk.TreeViewDropPosition.INTO_OR_AFTER , ''];\n\t        \n\t        Gdk.drag_status(ctx, action ,time);\n\t        return true;\n        }\n        \n        \n\n        //print(\"GETTING POS\");\n        Gtk.TreePath path;\n        var isOver = this.view.el.get_dest_row_at_pos(x,y, out path);\n        \n        //print(\"ISOVER? \" + isOver);\n        if (!isOver) {\n            Gdk.drag_status(ctx, 0 ,time);\n            return false; // not over apoint!?!\n        }\n        \n        // drag node is parent of child..\n        //console.log(\"SRC TREEPATH: \" + src.treepath);\n        //console.log(\"TARGET TREEPATH: \" + data.path.to_string());\n        \n        // nned to check a  few here..\n        //Gtk.TreeViewDropPosition.INTO_OR_AFTER\n        //Gtk.TreeViewDropPosition.INTO_OR_BEFORE\n        //Gtk.TreeViewDropPosition.AFTER\n        //Gtk.TreeViewDropPosition.BEFORE\n        \n        if (typeof(src.treepath) != 'undefined'  && \n            src.treepath == data.path.to_string().substring(0,src.treepath.length)) {\n            ///print(\"subpath drag\");\n             Gdk.drag_status(ctx, 0 ,time);\n            //return false;\n        }\n        \n        // check that \n        //print(\"DUMPING DATA\");\n        //console.dump(data);\n        // path, pos\n        \n        print(data.path.to_string() +' => '+  data.pos);\n        var tg = this.get('/LeftTree.model').findDropNodeByPath(\n            data.path.to_string(), src.dropList, data.pos);\n            \n        this.get('/LeftTree.view').highlight(tg);\n        if (!tg.length) {\n            print(\"Can not find drop node path\");\n            this.targetData = false;\n            Gdk.drag_status(ctx, 0, time);\n            return true;\n        }\n        //console.dump(tg);\n        this.targetData = tg;    \n        \n        \n        Gdk.drag_status(ctx, action ,time);\n         \n        return true;\n}",
                        "drag_drop": "function (w, ctx, x, y, time) {\n      Seed.print(\"TARGET: drag-drop\");\n                       \n                        Gtk.drag_get_data\n                        (\n                                w,         /* will receive 'drag-data-received' signal */\n                                ctx,        /* represents the current state of the DnD */\n                                this.get('/Window').atoms[\"STRING\"],    /* the target type we want */\n                                time            /* time stamp */\n                        );\n                        \n                         \n                        /* No target offered by source => error */\n                       \n\n                        return  true;\n}",
                        "drag_data_received": "function (self, ctx, x, y, sel_data, info, time) {\n\t print(\"Tree: drag-data-received\");\n\n              var   delete_selection_data = false;\n               var  dnd_success = false;\n                /* Deal with what we are given from source */\n                if( sel_data && sel_data.length ) {\n                    \n                    if (ctx.action == Gdk.DragAction.ASK)  {\n                        /* Ask the user to move or copy, then set the ctx action. */\n                    }\n\n                    if (ctx.action == Gdk.DragAction.MOVE) {\n                        //delete_selection_data = true;\n                    }\n                    \n                    var source = Gtk.drag_get_source_widget(ctx);\n\n                    if (this.targetData) {\n                        if (source != this.el) {\n                            this.get('/LeftTree.model').dropNode(this.targetData,  source.dragData);\n                        } else {\n                            // drag around.. - reorder..\n                             this.get('/LeftTree.model').moveNode(this.targetData, ctx.action);\n                            \n                            \n                        }\n                        //Seed.print(this.targetData);\n                      \n                    }\n                    \n                    \n                    \n                    // we can send stuff to souce here...\n\n                    dnd_success = true;\n\n                }\n\n                if (dnd_success == false)\n                {\n                        Seed.print (\"DnD data transfer failed!\\n\");\n                }\n\n                Gtk.drag_finish (ctx, dnd_success, delete_selection_data, time);\n                return true;\n}",
                        "cursor_changed": "function (self) {\n     if (this.blockChanges) { // probably not needed.. \n       return true;\n     }\n     var render = this.get('/LeftTree').getRenderer();                \n   \n    \n    if (this.selection.count_selected_rows() < 1) {\n        this.get('/LeftPanel.model').load( false);\n        this.get('/MidPropTree').activeElement =  false;\n        this.get('/MidPropTree').hideWin();\n\n        var pm = this.get('/RightPalete.model');\n        if (!this.get('/LeftTree').getPaleteProvider()) {\n            // it may not be loaded yet..\n            return  true;\n        }\n        pm.load( this.get('/LeftTree').getPaleteProvider().gatherList(\n            this.get('/LeftTree.model').listAllTypes()));\n        if (render && render.redraw) {\n            render.redraw();\n        }\n        return true;\n    }\n            \n            //console.log('changed');\n        var s = this.selection;\n          var iter = new Gtk.TreeIter();\n        s.get_selected(this.get('/LeftTree.model').el, iter);\n        \n        \n        // var val = \"\";\n        var value = new GObject.Value('');\n        this.get('/LeftTree.model').el.get_value(iter, 2, value);\n        this.get('/LeftTree.model').activePath = this.get('/LeftTree.model').el.get_path(iter).to_string();\n        \n        var data = JSON.parse(value.value);\n        this.get('/MidPropTree').activeElement =  data;\n        this.get('/MidPropTree').hideWin();\n        this.get('/LeftPanel.model').load( data);\n        \n        console.log(value.value);\n       // _g.button.set_label(''+value.get_string());\n\n        var pm =this.get('/RightPalete.model');\n        pm.load(  this.get('/LeftTree').getPaleteProvider().gatherList(\n             this.get('/LeftTree.model').listAllTypes()));\n       \n        \n           if (render && render.redraw) {\n            render.redraw();\n        }\n           \n            //Seed.print( value.get_string());\n            return true;\n                \n}"
                    },
                    ".GLib.List:dragList": "",
                    ".string:dragData": "",
                    "id": "view",
                    "pack": "add",
                    "tooltip_column": 1,
                    "xtype": "TreeView",
                    "|enable_tree_lines": "true",
                    "|headers_visible": "false",
                    "|highlight": "function(treepath_ar) {\n\n        // highlighting for drag/drop\n        if (treepath_ar.length && treepath_ar[0].length ) {\n            this.el.set_drag_dest_row( \n                    new  Gtk.TreePath.from_string( treepath_ar[0] ),  treepath_ar[1]);\n            } else {\n                this.el.set_drag_dest_row(null, Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n            }\n             \n        }",
                    "|init": "function() {\n    \tXObject.prototype.init.call(this);\n\tvar description = new Pango.FontDescription.c_new();\n\tdescription.set_size(8000);\n\tthis.el.modify_font(description);\n\n\tthis.selection = this.el.get_selection();\n\tthis.selection.set_mode( Gtk.SelectionMode.SINGLE);\n\tvar _this = this;\n\n\t// is this really needed??\n\tthis.selection.signal['changed'].connect(function() {\n\t\t_this.get('/LeftTree.view').listeners.cursor_changed.apply(\n\t\t    _this.get('/LeftTree.view'), [ _this.get('/LeftTree.view'), '']\n\t\t);\n\t});\n\n\tGtk.drag_source_set (\n\t\tthis.el,            /* widget will be drag-able */\n\t\tGdk.ModifierType.BUTTON1_MASK,       /* modifier that will start a drag */\n\t\tnull,            /* lists of target to support */\n\t\t0,              /* size of list */\n\t\tGdk.DragAction.COPY   | Gdk.DragAction.MOVE           /* what to do with data after dropped */\n\t);\n\n\tGtk.drag_source_set_target_list(this.el, this.get('/Window').targetList);\n\n\tGtk.drag_source_add_text_targets(this.el); \n\tGtk.drag_dest_set\n\t(\n\t    this.el,              /* widget that will accept a drop */\n\t    Gtk.DestDefaults.MOTION  | Gtk.DestDefaults.HIGHLIGHT,\n\t    null,            /* lists of target to support */\n\t    0,              /* size of list */\n\t    Gdk.DragAction.COPY   | Gdk.DragAction.MOVE       /* what to do with data after dropped */\n\t);\n\n\tGtk.drag_dest_set_target_list(this.el, this.get('/Window').targetList);\n\tGtk.drag_dest_add_text_targets(this.el);\n}\n",
                    "|selectNode": "function(treepath_str) {\n    //this.selection.select_path(new  Gtk.TreePath.from_string( treepath_str));\n var tp = new Gtk.TreePath.from_string(treepath_str);\n          this.el.set_cursor(tp, null, false);  \n      this.el.scroll_to_cell(tp, null, false, 0,0);\n}\n",
                    "|xns": "Gtk",
                    "items": [
                        {
                            "activePath": false,
                            "currentTree": false,
                            "id": "model",
                            "pack": "set_model",
                            "xtype": "TreeStore",
                            "|changed": "function(n, refresh) {\n    //     print(\"MODEL CHANGED CALLED\" + this.activePath);\n         if (this.activePath) {\n            var iter = new Gtk.TreeIter();\n            this.el.get_iter(iter, new Gtk.TreePath.from_string(this.activePath))\n            this.el.set_value(iter, 0, [GObject.TYPE_STRING, this.nodeTitle(n)]);\n            this.el.set_value(iter, 1, [GObject.TYPE_STRING, this.nodeTitle(n)]);\n            \n            this.el.set_value(iter, 2, [GObject.TYPE_STRING, this.nodeToJSON(n)]);\n        }\n            //this.currentTree = this.toJS(false, true)[0];\n        var d = new Date();\n        this.file.items = this.toJS(false, false);\n        print (\"TO JS in \" + ((new Date()) - d) + \"ms\");\n      //  print(\"AFTER CHANGED\");\n        //console.dump(this.file.items);\n        this.file.save();\n        this.currentTree = this.file.items[0];\n        //console.log(this.file.toSource());\n        \n        if (refresh) {\n            print(\"REDNER BROWSER?!\");\n            this.get('/LeftTree').renderView();\n\n            var pm = this.get('/RightPalete.model');\n            if (!this.get('/RightPalete').provider) {\n                pm.load([]);\n                return;\n            }\n            \n            \n            pm.load( this.get('/RightPalete').provider.gatherList(this.listAllTypes()));\n            //imports['Builder/RightBrowser.js'].renderJS(this.toJS());\n        }\n\t          \n}\n",
                            "|deleteSelected": "function() {\n    this.get('/LeftTree.view').blockChanges = true;\n    var old_iter = new Gtk.TreeIter();\n    var s = this.get('/LeftTree.view').selection;\n    s.get_selected(this.el, old_iter);\n    var path = this.el.get_path(old_iter).to_string();\n\n    this.activePath= false;      \n    s.unselect_all();\n\n    this.activePath= false;      \n     var iter = new Gtk.TreeIter();\n    this.el.get_iter_from_string(iter, path);\n    this.el.remove(iter);\n    \n    // rebuild treemap. -- depreciated.!!\n    this.map = {};\n    this.treemap = { };\n    //this.toJS(null, true) // does not do anything?\n    this.activePath= false;      \n    this.changed(false,true);\n    this.get('/LeftTree.view').blockChanges = false;\n}\n",
                            "|dropNode": "function(target_data, node) {\n         print(\"drop Node\");\n     // console.dump(node);\n  //    console.dump(target_data);\n        var tp = target_data[0].length ? new  Gtk.TreePath.from_string( target_data[0] ) : false;\n        \n        print(\"add \" + tp + \"@\" + target_data[1]  );\n        var parent = tp;\n        var after = false;\n        if (tp && target_data[1]  < 2) { // before or after..\n            var ar = target_data[0].split(':');\n            ar.pop();\n            parent  = new  Gtk.TreePath.from_string( ar.join(':') );\n            after = tp;\n        }\n        var n_iter = new Gtk.TreeIter();\n        var iter_par = new Gtk.TreeIter();\n        var iter_after = after ? new Gtk.TreeIter() : false;\n        \n        \n        \n        if (parent !== false) {\n            this.el.get_iter(iter_par, parent);\n        } else {\n            iter_par = null;\n        }\n        \n        \n        if (tp && after) {\n            print(target_data[1]  > 0 ? 'insert_after' : 'insert_before');\n            this.el.get_iter(iter_after, after);\n            this.el[ target_data[1]  > 0 ? 'insert_after' : 'insert_before'](\n                    n_iter, iter_par, iter_after);\n            \n        } else {\n            this.el.append(n_iter, iter_par);\n            \n        }\n        \n        if (typeof(node) == 'string') {\n            var ar = node.split('.');\n            var xtype = ar.pop();\n            \n            node = {\n                '|xns' : ar.join('.'),\n                'xtype' : xtype\n            };\n            if (target_data.length == 3 && target_data[2].length) {\n                node['*prop'] = target_data[2];\n            }\n            node = this.get('/DialogTemplateSelect').show(node);\n            \n        }\n        // work out what kind of packing to use..\n        if (typeof(node.pack) == 'undefined'  && parent !== false) {\n            var pal = this.get('/LeftTree').getPaleteProvider();\n            if (pal.name == 'Gtk') {\n                var pname = pal.guessName(this.singleNodeToJS(parent.to_string()));\n                var cname = pal.guessName(node);\n                node.pack = pal.getDefaultPack(pname, cname);\n            }\n            \n        }\n        \n        \n        var xitems = [];\n        if (node.items) {\n            xitems = node.items;\n            delete node.items;\n        }\n// load children - if it has any..\n\n        if (xitems) {\n            this.load(xitems, n_iter);\n            this.get('/LeftTree.view').el.expand_row(this.el.get_path(n_iter), true);\n        }\n        if (tp && (xitems || after)) {\n            this.get('/LeftTree.view').el.expand_row(this.el.get_path(iter_par), true);\n        }\n        // wee need to get the empty proptypes from somewhere..\n        \n        //var olditer = this.activeIter;\n        this.activePath = this.el.get_path(n_iter).to_string();\n\n  // changed actually set's the node data..\n        this.changed(node, true);\n        \n        \n        \n        this.get('/LeftTree.view').el.set_cursor(this.el.get_path(n_iter), null, false);\n        \n        //Builder.MidPropTree._model.load(node);\n        //Builder.MidPropTree._win.hideWin();\n        //Builder.LeftPanel._model.load( node);\n        \n            \n}\n",
                            "|findDropNode": "function(treepath_str, targets) {\n\n// this is used by the dragdrop code in the roo version AFAIR..\n\n    \t\tvar path = treepath_str.replace(/^builder-/, '');\n            // treemap is depreciated... - should really check if model has any entries..\n\n            if (!this.el.iter_n_children(null)) {\n                print(\"NO KEYS\");\n                return [ '',  Gtk.TreeViewDropPosition.INTO_OR_AFTER];\n            }\n            print(\"FIND treepath: \" + path);\n            //console.dump(this.treemap);\n            \n            if (!treepath_str.match(/^builder-/)) {\n                return []; // nothing!\n            }\n            if (targets === true) {\n                return [ path ];\n            }\n            return this.findDropNodeByPath(path,targets) \n}\n",
                            "|findDropNodeByPath": "function(treepath_str, targets, pref) {\n    var path = treepath_str + ''; // dupe it..\n    pref = typeof(pref) == 'undefined' ?  Gtk.TreeViewDropPosition.INTO_OR_AFTER : pref;\n    var last = false;\n    //console.dump(this.treemap);\n    while (path.length) {\n        print(\"LOOKING FOR PATH: \" + path);\n        var node_data = this.singleNodeToJS(path);\n        if (node_data === false) {\n            print(\"node not found\");\n            return [];\n        }\n        \n        var xname = this.get('/LeftTree.model').file.guessName(node_data);\n        var match = false;\n        var prop = '';\n        targets.forEach(function(tg) {\n            if (match) {\n                return;;\n            }\n            if ((tg == xname)  ) {\n                match = tg;\n            }\n            if (tg.indexOf(xname +':') === 0) {\n                match = tg;\n                prop = tg.split(':').pop();\n            }\n        });\n        \n        if (match) {\n            if (last) { // pref is after/before..\n                // then it's after last\n                if (pref > 1) {\n                    return []; // do not allow..\n                }\n                return [ last, pref , prop];\n                \n            }\n            return [ path , Gtk.TreeViewDropPosition.INTO_OR_AFTER , prop];\n        }\n        var par = path.split(':');\n        last = path;\n        par.pop();\n        path = par.join(':');\n    }\n    \n    return [];\n            \n}\n",
                            "|getIterValue": " function (iter, col) {\n    var gval = new GObject.Value('');\n    this.el.get_value(iter, col ,gval);\n    return  gval.value;\n    \n    \n}",
                            "|init": "function() {\n    XObject.prototype.init.call(this);\n this.el.set_column_types ( 3, [\n            GObject.TYPE_STRING, // title \n            GObject.TYPE_STRING, // tip\n            GObject.TYPE_STRING // source..\n            ] );\n}\n",
                            "|listAllTypes": "function() {\n    var s = this.get('/LeftTree.view').selection;\n    print (\"LIST ALL TYPES: \" + s.count_selected_rows() );\n    \n    if (s.count_selected_rows() > 0) {\n        var iter = new Gtk.TreeIter();    \n        s.get_selected(this.el, iter);\n\n        // set some properties of the tree for use by the dropped element.\n        var value = new GObject.Value('');\n        this.el.get_value(iter, 2, value);\n        var data = JSON.parse(value.value);\n        \n        \n        var xname = this.get('/LeftTree.model').file.guessName(data);\n        console.log('selected:' + xname);\n        if (xname.length) {\n            return [ xname ];\n        }\n        return []; // could not find it..\n    }\n    \n    var ret = [ ];\n    \n   var _this = this;\n    function addall(li)\n    {\n        li.forEach(function(el) {\n            // this is specific to roo!!!?\n            if (!el) { // skip empty?\n                return;\n            }\n            var fullpath =  _this.file.guessName(el);\n            if (fullpath.length && ret.indexOf(fullpath) < 0) {\n                ret.push(fullpath);\n            }\n            \n            \n            if (el.items && el.items.length) {\n                addall(el.items);\n            }\n            \n        });\n        \n        \n    }\n    \n    addall([this.currentTree]);\n    \n    // only if we have nothing, should we add '*top'\n    if (!ret.length) {\n        ret = [ '*top' ];\n    }\n    //console.log('all types in tree');\n    //console.dump(ret);\n    \n    return ret;\n                            \n}\n",
                            "|load": "function(tr,iter)\n        {\n            var citer = new Gtk.TreeIter();\n            //this.insert(citer,iter,0);\n            for(var i =0 ; i < tr.length; i++) {\n                if (iter) {\n                    this.el.insert(citer,iter,-1);\n                } else {\n                    this.el.append(citer);\n                }\n                \n                this.el.set_value(citer, 0, [GObject.TYPE_STRING, this.nodeTitle(tr[i]) ]);\n                this.el.set_value(citer, 1, [GObject.TYPE_STRING, this.nodeTip(tr[i]) ]);\n                this.el.set_value(citer, 2, [GObject.TYPE_STRING, this.nodeToJSON(tr[i])]);\n                if (tr[i].items && tr[i].items.length) {\n                    this.load(tr[i].items, citer);\n                }\n            }     \n        }",
                            "|loadFile": "function(f) {\n    //console.dump(f);\n            this.el.clear();\n            this.file = f;\n            \n            if (!f) {\n                console.log('missing file');\n                return;\n            }\n            \n            // load the file if not loaded..\n            if (f.items === false) {\n                var _this = this;\n                f.loadItems(function() {\n                    _this.loadFile(f);\n                });\n                return;\n                \n            }\n            this.get('/Window').setTitle(f.project.getName() + ' - ' + f.name);\n            \n            if (f.items.length && typeof(f.items[0]) == 'string') {\n            \n                //this.get('/RightEditor').el.show();\n                //this.get('/RightEditor.view').load( f.items[0]);\n                return;\n            }\n            print(\"LOAD\");\n            print(JSON.stringify(f.items, null,4));\n            //console.dump(f.items);\n            this.load(f.items);\n            this.get('/LeftTree.view').el.expand_all();\n\n            if (!f.items.length) {\n                // single item..\n                \n                this.get('/Window.leftvpaned').el.set_position(80);\n                // select first...\n                this.get('/LeftTree.view').el.set_cursor( \n                    new  Gtk.TreePath.from_string('0'), null, false);\n                \n                \n            } else {\n                  this.get('/Window.leftvpaned').el.set_position(200);\n            }\n            \n            \n            //print(\"hide right editior\");\n            //this.get('/RightEditor').el.hide();\n            this.get('/Editor').el.hide();\n            //print(\"set current tree\");\n            this.currentTree = this.toJS(false, false)[0];\n            //console.dump(this.currentTree);\n            this.currentTree = this.currentTree || { items: [] };\n            this.get('/LeftTree').renderView();\n            //console.dump(this.map);\n            //var RightPalete     = imports.Builder.RightPalete.RightPalete;\n            var pm = this.get('/RightPalete.model');\n            // set up provider..\n            \n            this.get('/RightPalete').provider = this.get('/LeftTree').getPaleteProvider();\n            \n            if (!this.get('/RightPalete').provider) {\n                print (\"********* PALETE PROVIDER MISSING?!!\");\n            }\n            this.get('/LeftTree').renderView();\n            \n            pm.load( this.get('/LeftTree').getPaleteProvider().gatherList(this.listAllTypes()));\n            \n            \n                    \n            this.get('/Window.view-notebook').el.set_current_page(\n                this.get('/LeftTree.model').file.getType()== 'Roo' ? 0 : -1);\n                    \n}\n",
                            "|moveNode": "function(target_data, action) {\n     //print(\"MOVE NODE\");\n           // console.dump(target_data);\n            var old_iter = new Gtk.TreeIter();\n            var s = this.get('/LeftTree.view').selection;\n            s.get_selected(this.el, old_iter);\n            var node = this.nodeToJS(old_iter,false);\n            //console.dump(node);\n            \n            \n            // needs to drop first, otherwise the target_data \n            // treepath will be invalid.\n            \n            this.dropNode(target_data, node);\n\t  if (action & Gdk.DragAction.MOVE) {\n                      //          print(\"REMOVING OLD NODE\");\n                                this.el.remove(old_iter);\n                                \n            }\n            \n            this.activePath= false;\n            this.changed(false,true);\n}\n",
                            "|nodeTip": "function(c) {\n    var ret = this.nodeTitle(c,true);\n    var funcs = '';\n\n    \n    for( var i in c) {\n\n        if (!i.length || i[0] != '|') {\n            continue;\n        }\n        if (i == '|init') { \n            continue;\n        }\n        if (typeof(c[i]) != 'string') {\n           continue;\n        }\n        //print(\"prop : \" + i + ':' + c[i]);\n        if (!c[i].match(new RegExp('function'))) {\n            continue;\n        }\n        funcs += \"\\n<b>\" + i.substring(1) + '</b> : ' + c[i].split(/\\n/).shift();\n            \n    }\n    if (funcs.length) {\n        ret+=\"\\n\\nMethods:\" + funcs;\n    }\n    return ret;\n    \n}\n",
                            "|nodeTitle": "function(c, renderfull) {\n      var txt = [];\n    c = c || {};\n    var sr = (typeof(c['+buildershow']) != 'undefined') &&  !c['+buildershow'] ? true : false;\n    if (sr) txt.push('<s>');\n    if (typeof(c['*prop']) != 'undefined')   { txt.push(c['*prop']+ ':'); }\n    \n    if (renderfull && c['|xns']) {\n        txt.push(c['|xns']);\n    }\n    \n    if (c.xtype)      { txt.push(c.xtype); }\n    if (c.id)      { txt.push('<b>[id=' + c.id + ']</b>'); }\n    if (c.fieldLabel) { txt.push('[' + c.fieldLabel + ']'); }\n    if (c.boxLabel)   { txt.push('[' + c.boxLabel + ']'); }\n    \n    \n    if (c.layout)     { txt.push('<i>' + c.layout + '</i>'); }\n    if (c.title)      { txt.push('<b>' + c.title + '</b>'); }\n    if (c.label)      { txt.push('<b>' + c.label+ '</b>'); }\n    if (c.header)    { txt.push('<b>' + c.header + '</b>'); }\n    if (c.legend)      { txt.push('<b>' + c.legend + '</b>'); }\n    if (c.text)       { txt.push('<b>' + c.text + '</b>'); }\n    if (c.name)       { txt.push('<b>' + c.name+ '</b>'); }\n    if (c.region)     { txt.push('<i>(' + c.region + ')</i>'); }\n    if (c.dataIndex) { txt.push('[' + c.dataIndex+ ']'); }\n    \n    // for flat classes...\n    if (typeof(c['*class']) != 'undefined')  { txt.push('<b>' +  c['*class']+  '</b>'); }\n    if (typeof(c['*extends']) != 'undefined')  { txt.push(': <i>' +  c['*extends']+  '</i>'); }\n    \n    \n    if (sr) txt.push('</s>');\n    return (txt.length == 0 ? \"Element\" : txt.join(\" \"));\n}\n",
                            "|nodeToJS": "function (treepath, with_id) \n{\n    \n    var iter = treepath;  // API used to be iter here..\n    if (typeof(iter) == 'string') {\n        iter = new Gtk.TreeIter(); \n        if (!this.el.get_iter(iter, new Gtk.TreePath.from_string(treepath))) {\n            return false;\n        }\n    } \n    var par = new Gtk.TreeIter(); \n    var iv = this.getIterValue(iter, 2);\n   // print(\"IV\" + iv);\n    var k = JSON.parse(iv);\n    if (k.json && !this.el.iter_parent( par, iter  )) {\n        delete k.json;\n    }\n    \n    if (with_id) {\n        var treepath_str = this.el.get_path(iter).to_string();\n        // not sure how we can handle mixed id stuff..\n        if (typeof(k.id) == 'undefined')  {\n            k.id =  'builder-'+ treepath_str ;\n        }\n        \n        // needed??\n        this.treemap[  treepath_str ] = k;\n        k.xtreepath = treepath_str ;\n        \n    }\n    if (this.el.iter_has_child(iter)) {\n        citer = new Gtk.TreeIter();\n        this.el.iter_children(citer, iter);\n        k.items = this.toJS(citer,with_id);\n    }\n    return k;\n}\n",
                            "|nodeToJSON": "function(c) {\n    var o  = {}\n    for (var i in c) {\n        if (i == 'items') {\n             continue;\n        }\n        o[i] = c[i];\n    }\n    return JSON.stringify(o);\n}\n",
                            "|singleNodeToJS": "function (treepath) \n        {\n            var iter = new Gtk.TreeIter(); \n            if (!this.el.get_iter(iter, new Gtk.TreePath.from_string(treepath))) {\n                return false;\n            }\n            \n            var iv = this.getIterValue(iter, 2);\n           \n            return JSON.parse(iv);\n            \n        }",
                            "|toJS": "function(treepath, with_id)\n{\n    //Seed.print(\"WITHID: \"+ with_id);\n    var iter = treepath;  // API used to be iter here..\n    if (typeof(iter) == 'string') {\n        iter = new Gtk.TreeIter(); \n        if (!this.el.get_iter(iter, new Gtk.TreePath.from_string(treepath))) {\n            return false;\n        }\n    } \n    var first = false;\n    if (!iter) {\n        \n        this.treemap = { }; \n        \n        iter = new Gtk.TreeIter();\n        if (!this.el.get_iter_first(iter)) {\n            return [];\n        }\n        first = true;\n    } \n    \n    var ar = [];\n       \n    while (true) {\n        \n        var k = this.nodeToJS(iter, with_id); \n        ar.push(k);\n        \n        \n        if (!this.el.iter_next(iter)) {\n            break;\n        }\n    }\n    \n    if (treepath === false) {\n        //dupe!!!\n        return JSON.parse(JSON.stringify(ar));\n    }\n    \n    return ar;\n    // convert the list into a json string..\n\n    \n}",
                            "|xns": "Gtk"
                        },
                        {
                            "|xns": "Gtk",
                            "xtype": "TreeViewColumn",
                            "pack": "append_column",
                            "|init": "function() {\n    XObject.prototype.init.call(this);\n   this.el.add_attribute(this.items[0].el , 'markup', 0 );\n}\n",
                            "items": [
                                {
                                    "|xns": "Gtk",
                                    "xtype": "CellRendererText",
                                    "pack": "pack_start"
                                }
                            ]
                        }
                    ]
                },
                {
                    "|xns": "Gtk",
                    "xtype": "Menu",
                    "pack": false,
                    "id": "LeftTreeMenu",
                    "items": [
                        {
                            "|xns": "Gtk",
                            "xtype": "MenuItem",
                            "pack": "add",
                            "label": "Delete Element",
                            "listeners": {
                                "activate": "function (self) {\n\n     this.get('/LeftTree.model').deleteSelected();\n}"
                            }
                        },
                        {
                            "listeners": {
                                "activate": "function (self) {\n\n     var tree = this.get('/LeftTree');\n      var model = this.get('/LeftTree.model');\n     var el = tree.getActivePath();\n     print(el);\n     var js = model.toJS(el, false);\n    // print(JSON.stringify(js[0], null,4));\n     this.get('/DialogSaveTemplate').show(JSON.stringify(js[0], null,4));\n     \n    \n}"
                            },
                            "label": "Save as Template",
                            "pack": "add",
                            "xtype": "MenuItem",
                            "|xns": "Gtk"
                        }
                    ]
                }
            ]
        }
    ],
    "permname": "",
    "modOrder": ""
}