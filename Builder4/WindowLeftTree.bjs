{
    "id": "file-gtk-11",
    "name": "WindowLeftTree",
    "parent": "",
    "title": false,
    "path": "/home/alan/gitlive/app.Builder.js/Builder4/WindowLeftTree.bjs",
    "items": [
        {
            "pack": "add",
            "xtype": "ScrolledWindow",
            "|JsRender.JsRender:getActiveFile": "() {\n    return this.model.file;\n}\n",
            "|JsRender.Node?:getActiveElement": " () { // return path to actie node.\n\n     var path = this.getActivePath();\n     if (path.length < 1) {\n        return null;\n     }\n     return _this.model.pathToNode(path);\n}\n",
            "|init": " this.el.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)\n \n",
            "|shadow_type": "Gtk.ShadowType.IN",
            "|string:getActivePath": " () {\n    var model = this.model;\n    var view = this.view;\n    if (view.el.get_selection().count_selected_rows() < 1) {\n        return \"\";\n    }\n    Gtk.TreeIter iter;\n    Gtk.TreeStore mod;\n    view.selection.get_selected(out mod, out iter);\n    return mod.get_path(iter).to_string();\n}\n",
            "|void:getRenderer": "() {\n\n    /*\n    switch( this.getActiveFile().getType()) {\n        case 'Roo':\n            return this.get('/RightBrowser.view');\n        case 'Gtk':\n            return this.get('/RightGtkView');\n    }\n    */\n\n}\n",
            "|void:renderView": "() {\n    \n    _this.model.file.renderJS();\n\n}\n",
            "|xns": "Gtk",
            "items": [
                {
                    "listeners": {
                        "button_press_event": "  ( ev) => {\n    //console.log(\"button press?\");\n\n    if (!_this.model.file.editor.save()) {\n    \n        // popup!! - click handled.. \n        return true;\n    }\n\n    if (ev.type != Gdk.EventType.BUTTON_PRESS  || ev.button != 3) {\n        //print(\"click\" + ev.type);\n        return true;\n    }\n    Gtk.TreePath res;\n    _this.view.el.get_path_at_pos((int)ev.x,(int)ev.y, out res);\n        \n      //if (!this.get('/LeftTreeMenu').el)  { \n      //      this.get('/LeftTreeMenu').init(); \n      //  }\n        \n     _this.LeftTreeMenu.el.set_screen(Gdk.Screen.get_default());\n     _this.LeftTreeMenu.el.show_all();\n      _this.LeftTreeMenu.el.popup(null, null, null, null, 3, ev.button.time);\n     //   print(\"click:\" + res.path.to_string());\n      return true;\n}",
                        "drag_begin": "( ctx)  => {\n\t//print('SOURCE: drag-begin');\n        \n        \n        this.targetData = \"\";\n        \n        // find what is selected in our tree...\n        Gtk.TreeIter iter;\n        var s = this.model.get_selection();\n        Gtk.TreeStore mod;\n        s.get_selected(out mod, out iter);\n\n        // set some properties of the tree for use by the dropped element.\n        GLib.Value value;\n        _this.model.el.get_value(iter, 2, out value);\n        var data = (JsRender.Node)(value.value);\n        var xname = data.fqn();\n        \n        this.dragData = xname;\n        this.dropList = this.file.getPalete().getDropList(xname);\n        \n\n        // make the drag icon a picture of the node that was selected\n        var path = _this.model.el.get_path(iter);\n\n        this.treepath = path.to_string();\n        \n        var pix = this.el.create_row_drag_icon ( path);\n        \n        Gtk.drag_set_icon_surface (ctx, pix) ;\n        \n        return true;\n}",
                        "drag_end": "  (drag_context) => {\n\t//Seed.print('LEFT-TREE: drag-end');\n        this.dragData = \"\";\n        this.dropList = null;\n        this.targetData = \"\";\n        this.view.highlight(false);\n//        return true;\n}",
                        "drag_motion": " ( ctx, x, y, time)  => {\n \n    // the point of this is to detect where an item could be dropped..\n    \n       this.drag_in_motion = true;\n       this.drag_x = x;\n       this.drag_y = y;\n       \n            // request data that will be recieved by the recieve...              \n        Gtk.drag_get_data\n        (\n                this.el,         // will receive 'drag-data-received' signal \n                ctx,        // represents the current state of the DnD \n                Atom.intern(\"STRING\",true),    // the target type we want \n                time            // time stamp \n        );\n    return;\n       \n}",
                        "drag_drop": " (  ctx, x, y, time)  => {\n      //Seed.print(\"TARGET: drag-drop\");\n        \n        // request data that will be recieved by the recieve...              \n    Gtk.drag_get_data\n    (\n            this.el,         // will receive 'drag-data-received' signal \n            ctx,        // represents the current state of the DnD \n            Atom.intern(\"STRING\",true),    // the target type we want \n            time            // time stamp \n    );\n\n     \n    // No target offered by source => error\n   \n\n    return  true;\n}",
                        "drag_data_received": "  (ctx, x, y, sel, info, time)  => {\n      //print(\"Tree: drag-data-received\");\n\n\n     \n     \n        //console.log(\"LEFT-TREE: drag-motion\");\n        var src = Gtk.drag_get_source_widget(ctx);\n        \n        // a drag from  elsewhere...- prevent drop..\n        if (src != this.el) {\n            //print(\"no drag data!\");\n            // fix-me - this.. needs to handle comming from the palete...\n            if (this.drag_in_motion) {\n                Gdk.drag_status(ctx, 0, time);\n                return;\n            }\n            Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n            // no drop action...\n            return;\n        }\n            \n        var  targetData = \"\";\n        //var action = Gdk.DragAction.COPY;\n            // unless we are copying!!! ctl button..\n        var action = ctx.actions & Gdk.DragAction.MOVE ? Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;\n        \n        \n        if (this.model.el.iter_n_children(null) < 1) {\n            // no children.. -- asume it's ok..\n            \n            targetData = \"|%d|\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n            if (this.drag_in_motion) {            \n                Gdk.drag_status(ctx, action ,time);\n                return;\n            }\n            // continue through to allow drop...\n\n        } else {\n            \n            \n\n            //print(\"GETTING POS\");\n            Gtk.TreePath path;\n            Gtk.TreeViewDropPosition pos;\n            var isOver = this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);\n            \n            //print(\"ISOVER? \" + isOver);\n            if (!isOver) {\n                if (this.drag_in_motion) {\n                    Gdk.drag_status(ctx, 0 ,time);\n                }\n                Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n                return; // not over apoint!?! - no action on drop or motion..\n            }\n            \n            // drag node is parent of child..\n            //console.log(\"SRC TREEPATH: \" + src.treepath);\n            //console.log(\"TARGET TREEPATH: \" + data.path.to_string());\n            \n            // nned to check a  few here..\n            //Gtk.TreeViewDropPosition.INTO_OR_AFTER\n            //Gtk.TreeViewDropPosition.INTO_OR_BEFORE\n            //Gtk.TreeViewDropPosition.AFTER\n            //Gtk.TreeViewDropPosition.BEFORE\n            \n            // what's in the selected data....\n            var selection_text = sel.get_text();\n            // see if we are dragging into ourself?\n            \n            \n            \n            if (selection_text  == path.to_string().substring(0,selection_text.length)) {\n                ///print(\"subpath drag\");\n                if (this.drag_in_motion) {\n                     Gdk.drag_status(ctx, 0 ,time);\n                 }\n                 Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n                 return; /// -- fixme -- this is not really correct..\n\n            }\n            \n            // check that \n            //print(\"DUMPING DATA\");\n            //console.dump(data);\n            // path, pos\n            \n            //print(data.path.to_string() +' => '+  data.pos);\n            \n            // dropList is a list of xtypes that this node could be dropped on.\n            // it is set up when we start to drag..\n            \n            \n            targetData = this.model.findDropNodeByPath( path.to_string(), this.dropList, pos);\n                \n\n            \n            if (tg.length < 1) {\n                //print(\"Can not find drop node path\");\n                if (this.drag_in_motion) {\n                    Gdk.drag_status(ctx, 0, time);\n                }\n                Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n                return;\n            }\n            \n            this.view.highlight(tg);\n            //console.dump(tg);\n            targetData = tg;    \n            \n            if (this.drag_in_motion) { \n                Gdk.drag_status(ctx, action ,time);\n                return;\n            }\n            // continue on to allow drop..\n        }\n\n        // at this point, drag is not in motion... -- as checked above... - so it's a real drop event..\n\n\n         var delete_selection_data = false;\n            \n        if (ctx.action == Gdk.DragAction.ASK)  {\n            /* Ask the user to move or copy, then set the ctx action. */\n        }\n\n        if (ctx.action == Gdk.DragAction.MOVE) {\n            delete_selection_data = true;\n        }\n        \n            \n                    // drag around.. - reorder..\n        _this.model.moveNode(targetData, ctx.action);\n            \n           \n            \n            \n            \n            // we can send stuff to souce here...\n\n\n\n        Gtk.drag_finish (ctx, true, delete_selection_data, time);\n       \n}",
                        "cursor_changed": " ( ) => {\n\n\n     if (this.blockChanges) { // probably not needed.. \n       return true;\n     }\n     \n     \n     //var render = this.get('/LeftTree').getRenderer();                \n   \n    \n    if (_this.model.get_selection().count_selected_rows() < 1) {\n\n\n        //??this.model.load( false);\n        \n        this.file.setActiveNode(null);\n        \n        return true;\n    }\n            \n            //console.log('changed');\n        var s = this.get_selection();\n         Gtk.TreeIter iter;\n         Gtk.TreeStore mod;\n        s.get_selected(out mod, out iter);\n        \n        \n        // var val = \"\";\n        GLib.Value value;\n        this.model.el.get_value(iter, 2, out value);\n        this.model.activePath = mod.get_path(iter).to_string();\n        \n        var node = (JsRender.Node)value.dup_object();\n\n        this.file.setActiveNode(node);\n       \n        //Seed.print( value.get_string());\n        return true;\n                \n}"
                    },
                    ".GLib.List:dragList": "",
                    ".bool:blockChanges": "false",
                    ".bool:drag_in_motion": "",
                    ".int:drag_x": "",
                    ".int:drag_y": "",
                    ".string:dragData": "",
                    "id": "view",
                    "pack": "add",
                    "tooltip_column": 1,
                    "xtype": "TreeView",
                    "|enable_tree_lines": "true",
                    "|headers_visible": "false",
                    "|init": "{\n    var description = new Pango.FontDescription();\n    description.set_size(8000);\n    this.el.modify_font(description);\n\n    var selection = this.el.get_selection();\n    selection.set_mode( Gtk.SelectionMode.SINGLE);\n\n\n    // is this really needed??\n    /*\n    this.selection.signal['changed'].connect(function() {\n\t    _this.get('/LeftTree.view').listeners.cursor_changed.apply(\n\t        _this.get('/LeftTree.view'), [ _this.get('/LeftTree.view'), '']\n\t    );\n    });\n    */\n    Gtk.drag_source_set (\n\t    this.el,            /* widget will be drag-able */\n\t    Gdk.ModifierType.BUTTON1_MASK,       /* modifier that will start a drag */\n\t    null,            /* lists of target to support */\n\t    0,              /* size of list */\n\t    Gdk.DragAction.COPY   | Gdk.DragAction.MOVE           /* what to do with data after dropped */\n    );\n\n    Gtk.drag_source_set_target_list(this.el, Builder.Application.targetList);\n\n    Gtk.drag_source_add_text_targets(this.el); \n\n    Gtk.drag_dest_set\n    (\n        this.el,              /* widget that will accept a drop */\n        Gtk.DestDefaults.MOTION  | Gtk.DestDefaults.HIGHLIGHT,\n        null,            /* lists of target to support */\n        0,              /* size of list */\n        Gdk.DragAction.COPY   | Gdk.DragAction.MOVE       /* what to do with data after dropped */\n    );\n\n    Gtk.drag_dest_set_target_list(this.el, Builder.Application.targetList);\n    Gtk.drag_dest_add_text_targets(this.el);\n}\n",
                    "|void:highlight": " ( bool treepath_ar) {\n\n        // highlighting for drag/drop\n//        if (treepath_ar.length && treepath_ar[0].length ) {\n  //          this.el.set_drag_dest_row( \n  //                  new  Gtk.TreePath.from_string( treepath_ar[0] ),  \n  //                    treepath_ar[1]\n//            );\n  //          } else {\n                this.el.set_drag_dest_row(null, Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n   //         }\n             \n        }",
                    "|void:selectNode": "(string treepath_str) {\n    //this.selection.select_path(new  Gtk.TreePath.from_string( treepath_str));\n     var tp = new Gtk.TreePath.from_string(treepath_str);\n     \n     this.el.set_cursor(tp, null, false);  \n     this.el.scroll_to_cell(tp, null, false, 0,0);\n}\n",
                    "|xns": "Gtk",
                    "items": [
                        {
                            ".JsRender.JsRender:file": "",
                            ".string:activePath": "",
                            "currentTree": false,
                            "id": "model",
                            "n_columns": 3,
                            "pack": "set_model",
                            "xtype": "TreeStore",
                            "|JsRender.Node:pathToNode": "(string path) {\n \n     \n     Gtk.TreeIter   iter;\n     _this.model.el.get_iter_from_string(out iter, path);\n     \n     GLib.Value value;\n     _this.model.el.get_value(iter, 2, out value);\n     \n     return (JsRender.Node)value.dup_object();\n\n}",
                            "|columns": "typeof(string),typeof(string),typeof(Object)",
                            "|listAllTypes": "function() {\n    var s = this.get('/LeftTree.view').selection;\n    print (\"LIST ALL TYPES: \" + s.count_selected_rows() );\n    \n    if (s.count_selected_rows() > 0) {\n        var iter = new Gtk.TreeIter();    \n        s.get_selected(this.el, iter);\n\n        // set some properties of the tree for use by the dropped element.\n        var value = new GObject.Value('');\n        this.el.get_value(iter, 2, value);\n        var data = JSON.parse(value.value);\n        \n        \n        var xname = this.get('/LeftTree.model').file.guessName(data);\n        console.log('selected:' + xname);\n        if (xname.length) {\n            return [ xname ];\n        }\n        return []; // could not find it..\n    }\n    \n    var ret = [ ];\n    \n   var _this = this;\n    function addall(li)\n    {\n        li.forEach(function(el) {\n            // this is specific to roo!!!?\n            if (!el) { // skip empty?\n                return;\n            }\n            var fullpath =  _this.file.guessName(el);\n            if (fullpath.length && ret.indexOf(fullpath) < 0) {\n                ret.push(fullpath);\n            }\n            \n            \n            if (el.items && el.items.length) {\n                addall(el.items);\n            }\n            \n        });\n        \n        \n    }\n    \n    addall([this.currentTree]);\n    \n    // only if we have nothing, should we add '*top'\n    if (!ret.length) {\n        ret = [ '*top' ];\n    }\n    //console.log('all types in tree');\n    //console.dump(ret);\n    \n    return ret;\n                            \n}\n",
                            "|string:findDropNode": " (string treepath_str, string[] targets) {\n\n    // this is used by the dragdrop code in the roo version AFAIR..\n\n    //var path = treepath_str.replace(/^builder-/, '');\n    // treemap is depreciated... - should really check if model has any entries..\n\n    if (this.el.iter_n_children(null) < 1) {\n        //print(\"NO KEYS\");\n        return \"|%d\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n    }\n    //print(\"FIND treepath: \" + path);\n    //console.dump(this.treemap);\n    \n    //if (!treepath_str.match(/^builder-/)) {\n    //    return []; // nothing!\n    //}\n    if (targets.length > 0 && targets[0] == \"*\") {\n        return  treepath_str;\n    }\n    return this.findDropNodeByPath(treepath_str,targets, -1);\n}\n",
                            "|string:findDropNodeByPath": " (string treepath_str, string[] targets, int in_pref = -1) {\n\n    var path = treepath_str; // dupe it..\n    \n    int pref = in_pref < 0  ?  Gtk.TreeViewDropPosition.INTO_OR_AFTER : in_pref;\n    \n    var last = \"\";\n    \n    //console.dump(this.treemap);\n    \n    while (path.length > 0) {\n        //print(\"LOOKING FOR PATH: \" + path);\n        var node_data = this.pathToNode(path);\n        \n        if (node_data == null) {\n            print(\"node not found\");\n            return null;\n        }\n        \n        var xname = node_data.fqn();\n        var match = \"\";\n        var prop = \"\";\n        \n        for (var i =0; i < targets.length; i++)  {\n            var tg = targets[i];\n            if ((tg == xname)  ) {\n                match = tg;\n                break;\n            }\n            // if target is \"xxxx:name\"\n            if (tg.contains(xname +\":\")) {\n                match = tg;\n                var ar = tg.split(\":\");\n                prop = ar[1];\n                break;\n            }\n        }\n        \n        if (match.length > 0) {\n            if (last.length > 0) { // pref is after/before..\n                // then it's after last\n                if (pref > 1) {\n                    return \"\";\n                }\n                return last + \"|%d\".printf((int)pref) + \"|\" + prop;\n\n                \n            }\n            return path + \"|%d\".printf( (int) Gtk.TreeViewDropPosition.INTO_OR_AFTER) + \"|\" + prop;\n        }\n        \n        var par = path.split(\":\");\n        last = \"\" + path;\n        par[par.length] = \"\";\n        path = string.joinv(\":\", par).substring(0,-2);\n    }\n    \n    return \"\";\n            \n}\n",
                            "|void:deleteSelected": "() {\n    \n    \n    _this.view.blockChanges = true;\n    \n    Gtk.TreeIter old_iter = new Gtk.TreeIter();\n    var s = _this.view.el.get_selection();\n    Gtk.TreeModel mod;\n    \n    s.get_selected(out mod, out old_iter);\n    \n    var path = mod.get_path(old_iter).to_string();\n\n    this.activePath= \"\";      \n    s.unselect_all();\n\n    this.activePath= \"\";      \n    \n    Gtk.TreeIter iter;\n    this.el.get_iter_from_string(out iter, path);\n\n    GLib.Value value;\n    this.el.get_value(iter, 2, out value);\n    var data = (JsRender.Node)value.dup_object();\n    data.remove();\n    this.el.remove(ref iter);\n    \n    \n    // \n    \n    \n\n\n    this.activePath= \"\"; // again!?!?      \n    //this.changed(null,true);\n    \n    this.file.changed(null, \"tree\");\n    \n    _this.view.blockChanges = false;\n}\n",
                            "|void:dropNode": "(string target_data_str, JsRender.Node node) {\n//         print(\"drop Node\");\n     // console.dump(node);\n  //    console.dump(target_data);\n  \n        var target_data= target_data_str.split(\"|\");\n  \n        Gtk.TreePath tp = target_data[0].length > 0 ? new  Gtk.TreePath.from_string( target_data[0] ) : null;\n        \n         Gtk.TreePath parent = null;\n        //print(\"add \" + tp + \"@\" + target_data[1]  );\n        \n        JsRender.Node parentNode = null;\n        \n          parent = tp;\n        \n        Gtk.TreePath after = null;\n        \n        if (tp != null && int.parse(target_data[1])  < 2) { // before or after..\n            var ar = target_data[0].split(\":\");\n            ar[ar.length-1] = \"\";\n            var npath = string.joinv(\":\", ar);\n            \n            \n            parent  = new  Gtk.TreePath.from_string( npath.substring( 0, -2 ));\n            \n            \n            \n            \n            after = tp;\n        }\n        Gtk.TreeIter? n_iter;\n        Gtk.TreeIter? iter_par;\n\n        Gtk.TreeIter? iter_after;\n        \n        \n        \n        if (parent != null) {\n            this.el.get_iter(out iter_par, parent);\n            GLib.Value value;\n            this.el.get_value( iter_par, 2, out value);\n              parentNode =  (JsRender.Node)value.dup_object();\n        } else {\n            iter_par = null;\n        }\n        \n        \n        if (tp != null && after != null) {\n            //print(target_data[1]  > 0 ? 'insert_after' : 'insert_before');\n            \n            this.el.get_iter(out iter_after, after);\n            if ( int.parse(target_data[1]) >0 ) {\n                this.el.insert_after(out n_iter, iter_par, iter_after);\n            } else {\n                this.el.insert_before(out n_iter, iter_par, iter_after);\n            }\n            \n        } else {\n            this.el.append(out n_iter, iter_par);\n            \n        }\n        \n        if (node.parent == null) {\n        \n            if (target_data.length == 3 && target_data[2].length > 0) {\n                node.props.set(\"*prop\", target_data[2]);\n            }\n            \n            var new_node = DialogTemplateSelect.show(this.file.palete(), node);\n            node = new_node;\n            \n        }\n        \n        \n        // work out what kind of packing to use.. -- should be in \n        if (!node.has(\"pack\")   && parent != null) {\n        \n            this.file.palete().fillPack(node,parentNode);\n            \n            \n        }\n        \n        \n        \n// load children - if it has any..\n\n        if (node.items.length() > 0) {\n            this.load(node.items, n_iter);\n            _this.view.el.expand_row(this.el.get_path(n_iter), true);\n        }\n        \n        if (tp != null && (node.items.length() > 0 || after != null)) {\n            _this.view.el.expand_row(this.el.get_path(iter_par), true);\n        }\n        // wee need to get the empty proptypes from somewhere..\n        \n        //var olditer = this.activeIter;\n        this.activePath = this.el.get_path(n_iter).to_string();\n\n  // changed actually set's the node data..\n        this.updateNode(node, true);\n        \n        \n        _this.view.el.set_cursor(this.el.get_path(n_iter), null, false);\n        \n        //Builder.MidPropTree._model.load(node);\n        //Builder.MidPropTree._win.hideWin();\n        //Builder.LeftPanel._model.load( node);\n        \n            \n}\n",
                            "|void:load": "(GLib.List<JsRender.Node> tr, Gtk.TreeIter? iter) \n{\n    Gtk.TreeIter citer;\n    //this.insert(citer,iter,0);\n    for(var i =0 ; i < tr.length(); i++) {\n        if (iter != null) {\n            this.el.insert(out citer,iter,-1); // why not append?\n        } else {\n            this.el.append(out citer,null);\n        }\n        \n        this.el.set(citer, 0, tr.nth_data(i).nodeTitle(),\n                1, tr.nth_data(i).nodeTip(), -1\n        );\n        var o = new GLib.Value(typeof(Object));\n        o.set_object((Object)tr.nth_data(i));\n        \n        this.el.set_value(citer, 2, o);\n        \n        if (tr.nth_data(i).items.length() > 0) {\n            this.load(tr.nth_data(i).items, citer);\n        }\n     \n    }\n}",
                            "|void:loadFile": "(JsRender.JsRender f) {\n    //console.dump(f);\n    this.el.clear();\n    this.file = f;\n    \n//    if (!f) {\n//        console.log('missing file');\n//        return;\n//    }\n    \n    // load the file if not loaded..\n    if (f.tree == null) {\n        f.loadItems( );\n    }\n    \n    \n    \n    /// this.get('/Window').setTitle(f.project.getName() + ' - ' + f.name);\n    \n    //if (f.items.length && typeof(f.items[0]) == 'string') {\n    \n        //this.get('/RightEditor').el.show();\n        //this.get('/RightEditor.view').load( f.items[0]);\n    //    return;\n    //}\n    //print(\"LOAD\");\n    //print(JSON.stringify(f.items, null,4));\n    //console.dump(f.items);\n    var o = new GLib.List<JsRender.Node>();\n    o.append(f.tree);\n    this.load(o,null);\n    \n    _this.view.el.expand_all();\n\n    if (f.tree.items.length() < 1) {\n        // single item..\n        \n        //this.get('/Window.leftvpaned').el.set_position(80);\n        // select first...\n        _this.view.el.set_cursor( \n            new  Gtk.TreePath.from_string(\"0\"), null, false);\n        \n        \n    } else {\n          //this.get('/Window.leftvpaned').el.set_position(200);\n    }\n    \n    return;\n    /*    \n    \n    //print(\"hide right editior\");\n    //this.get('/RightEditor').el.hide();\n    //this.get('/Editor').el.hide();\n    //print(\"set current tree\");\n    //this.currentTree = this.toJS(false, false)[0];\n    //console.dump(this.currentTree);\n    //this.currentTree = this.currentTree || { items: [] };\n    //_this.renderView();\n    //console.dump(this.map);\n    //var RightPalete     = imports.Builder.RightPalete.RightPalete;\n    \n    \n    var pm = this.get('/RightPalete.model');\n    // set up provider..\n    \n    this.get('/RightPalete').provider = this.get('/LeftTree').getPaleteProvider();\n    \n    if (!this.get('/RightPalete').provider) {\n        print (\"********* PALETE PROVIDER MISSING?!!\");\n    }\n    this.get('/LeftTree').renderView();\n    \n    pm.load( this.get('/LeftTree').getPaleteProvider().gatherList(this.listAllTypes()));\n    \n    \n            \n    this.get('/Window.view-notebook').el.set_current_page(\n        this.get('/LeftTree.model').file.getType()== 'Roo' ? 0 : -1);\n        */\n            \n}\n",
                            "|void:moveNode": "(string target_data, Gdk.DragAction action) \n{\n    //print(\"MOVE NODE\");\n    // console.dump(target_data);\n    Gtk.TreeIter old_iter;\n    var s = _this.view.el.get_selection();\n    Gtk.TreeModel mod;\n    s.get_selected(out mod , out old_iter);\n    mod.get_path(old_iter);\n    \n    var node = this.pathToNode(mod.get_path(old_iter).to_string());\n    //console.dump(node);\n\n\n    // needs to drop first, otherwise the target_data \n    // treepath will be invalid.\n\n    \n    \n    if ((action & Gdk.DragAction.MOVE) > 0) {\n              //          print(\"REMOVING OLD NODE\");\n            node.remove();\n            this.dropNode(target_data, node);\n            this.el.remove(ref old_iter);\n            \n                         \n    } else {\n        node = node.deepClone();\n        this.dropNode(target_data, node);\n    }\n\n    this.activePath= \"\";\n    //this.updateNode(false,true);\n}\n",
                            "|void:updateNode": "(JsRender.Node? n, bool refresh)\n {\n    //     print(\"MODEL CHANGED CALLED\" + this.activePath);\n     if (n != null && this.activePath.length > 0) {\n        Gtk.TreeIter iter;\n        this.el.get_iter(out iter, new Gtk.TreePath.from_string(this.activePath));\n        this.el.set(iter, 0, n.nodeTitle(), 1, n.nodeTip(), -1);\n        var v = new Value(typeof(Object));\n        v.set_object((Object)n);\n    }\n              \n}\n",
                            "|xns": "Gtk"
                        },
                        {
                            "pack": "append_column",
                            "xtype": "TreeViewColumn",
                            "|init": "  this.el.add_attribute(_this.renderer , \"markup\", 0 );\n ",
                            "|xns": "Gtk",
                            "items": [
                                {
                                    "id": "renderer",
                                    "pack": "pack_start,true",
                                    "xtype": "CellRendererText",
                                    "|xns": "Gtk"
                                }
                            ]
                        }
                    ]
                },
                {
                    "|xns": "Gtk",
                    "xtype": "Menu",
                    "pack": false,
                    "id": "LeftTreeMenu",
                    "items": [
                        {
                            "listeners": {
                                "activate": "  ( ) => {\n\n     _this.model.deleteSelected();\n}"
                            },
                            "label": "Delete Element",
                            "pack": "add",
                            "xtype": "MenuItem",
                            "|xns": "Gtk"
                        },
                        {
                            "listeners": {
                                "activate": "  () => {\n\n\n      \n     DialogSaveTemplate.show( _this.getActiveElement());\n     \n    \n}"
                            },
                            "label": "Save as Template",
                            "pack": "add",
                            "xtype": "MenuItem",
                            "|xns": "Gtk"
                        }
                    ]
                }
            ]
        }
    ],
    "permname": "",
    "modOrder": ""
}