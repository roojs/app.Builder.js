{
    "id": "file-gtk-14",
    "name": "WindowRooView",
    "parent": "",
    "title": false,
    "path": "/home/alan/gitlive/app.Builder.js/Builder4/WindowRooView.bjs",
    "items": [
        {
            "id": "WindowRooView",
            "pack": "add",
            "xtype": "VBox",
            "|xns": "Gtk",
            "items": [
                {
                    "pack": "pack_start,false,true,0",
                    "xtype": "HBox",
                    "|xns": "Gtk",
                    "items": [
                        {
                            "listeners": {
                                "clicked": "( ) => {\n    _this.view.renderJS(null,true);\n}"
                            },
                            "label": "Redraw",
                            "pack": "pack_start,false,false,0",
                            "xtype": "Button",
                            "|xns": "Gtk"
                        },
                        {
                            "listeners": {
                                "toggled": " (state) => {\n    this.el.set_label(this.el.active  ? \"Auto Redraw On\" : \"Auto Redraw Off\");\n}"
                            },
                            "active": "true",
                            "id": "AutoRedraw",
                            "label": "Auto Redraw On",
                            "pack": "pack_start,false,false,0",
                            "xtype": "CheckButton",
                            "|xns": "Gtk"
                        },
                        {
                            "listeners": {
                                "clicked": " () => {\n  _this.view.redraws = 99;\n  _this.view.renderJS(null,true);\n}"
                            },
                            "label": "Full Redraw",
                            "pack": "pack_start,false,false,0",
                            "xtype": "Button",
                            "|xns": "Gtk"
                        }
                    ]
                },
                {
                    "pack": "add",
                    "xtype": "ScrolledWindow",
                    "|init": "function() {\n    XObject.prototype.init.call(this);\n    this.el.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC);\n}\n",
                    "|shadow_type": "Gtk.ShadowType.IN",
                    "|xns": "Gtk",
                    "items": [
                        {
                            "listeners": {
                                "load_finished": "function (self, object) {\n    print(\"load finished\");\n//    print(\"load_finished\"); return;\n\t// if (this.ready) { // dont do it twice!\n\t //   return; \n\t//}\n\tif (!this.inspectorShown) {\n           this.el.get_inspector().show();\n           this.inspectorShown = true;\n\t}\n\n\tthis.ready = true;\n\t\n        if (this.pendingRedraw) {\n            this.pendingRedraw = false;\n            this.refreshRequired  = true;\n        }\n        //var js = this.get('/LeftTree.model').toJS();\n        //if (js && js[0]) {\n    \t//    this.renderJS(js[0]);\n    \t//}\n\n}",
                                "script_alert": "function (self, object, p0) {\n    // \tprint(p0);\n        return false;\n        return true; // do not display anything...\n}",
                                "console_message": "function (self, object, p0, p1) {\n    print(object);\n   //  console.log(object);\n   \n\n    if (object.match(/variable/) && object.match(/Builder/)) {\n        print(\"got builder missing message\");\n        this.refreshRequired = true;\n        this.lastRedraw = 0;\n        this.runRefresh();\n        return true;\n    }\n    \n   \n        if (!object.match(/^\\{/)) {\n        \n            //this.get('/Terminal').feed(object);\n            return true; // do not handle!!! -> later maybe in console..\n        }\n        \n        \n        \n        \n       // console.log(object);\n        var val =  JSON.parse(object);\n\n        if (typeof(val['hover-node']) != 'undefined') {\n            this.activeNode = val['hover-node'];\n            console.log('active node: ' + this.activeNode);\n            return true;\n        }\n\n         var ret = false;\n         if (typeof(val['id']) != 'undefined') {\n           // this.activeNode = val['id'];\n            var tg = this.get('/LeftTree.model').findDropNode(val['id'], true); \n            if (!tg || typeof(tg[0]) == 'undefined') {\n                return false;\n            }\n            print(\"SELECT node \" + tg[0]);\n            \n            this.get('/LeftTree.view').selectNode(tg[0]);\n            ret  = true;\n            \n        } \n        if (ret && typeof(val['set']) != 'undefined') {\n           this.get('/LeftPanel.model').add({\n                key : val['set'],\n                val : val['value']\n            });\n            //console.log('active node: ' + this.activeNode);\n            \n        }\n        //Seed.print('a:'+a);\n        //Seed.print('b:'+b);\n        //Seed.print('c:'+c);\n        return ret;\n}",
                                "drag_motion": "function (w, ctx,  x,   y,   time, ud) {\n   // console.log('DRAG MOTION'); \n        // status:\n        // if lastCurrentNode == this.currentNode.. -- don't change anything..\n        this.targetData = [];\n        this.el.execute_script(\"Builder.overPos(\" + x +','+ y + \");\");\n        \n        // A) find out from drag all the places that node could be dropped.\n        var src = Gtk.drag_get_source_widget(ctx);\n        if (!src.dropList) {\n            Gdk.drag_status(ctx, 0, time);\n            return true;\n        }\n        // b) get what we are over.. (from activeNode)\n        // tree is empty.. - list should be correct..\n        if (!this.get('/LeftTree.model').currentTree) {\n            Gdk.drag_status(ctx, Gdk.DragAction.COPY,time);\n            return true;\n            \n        }\n        // c) ask tree where it should be dropped... - eg. parent.. (after node ontop)\n        \n        var tg = this.get('/LeftTree.model').findDropNode(this.activeNode, src.dropList);\n        console.dump(tg);\n        if (!tg.length) {\n            Gdk.drag_status(ctx, 0,time);\n            this.get('/LeftTree.view').highlight(false);\n            return true;\n        }\n         \n        // if we have a target..\n        // -> highlight it! (in browser)\n        // -> highlight it! (in tree)\n        \n        Gdk.drag_status(ctx, Gdk.DragAction.COPY,time);\n        this.get('/LeftTree.view').highlight(tg);\n        this.targetData = tg;\n        // for tree we should handle this...\n        return true;\n}",
                                "drag_drop": "function (w, ctx, x, y,time, ud) {\n\tprint(\"TARGET: drag-drop\");\n        var is_valid_drop_site = true;\n        \n         \n        Gtk.drag_get_data\n        (\n                w,         /* will receive 'drag-data-received' signal */\n                ctx,        /* represents the current state of the DnD */\n                this.get('/Window').atoms[\"STRING\"],    /* the target type we want */\n                time            /* time stamp */\n        );\n                        \n                        \n                        /* No target offered by source => error */\n                       \n\n\treturn  is_valid_drop_site;\n}",
                                "drag_data_received": "function (w, ctx,  x,  y, sel_data,  target_type,  time, ud) \n    {\n        print(\"Browser: drag-data-received\");\n        var delete_selection_data = false;\n        vardnd_success = false;\n        /* Deal with what we are given from source */\n        if( sel_data && sel_data.length ) {\n            \n            if (ctx.action == Gdk.DragAction.ASK)  {\n                /* Ask the user to move or copy, then set the ctx action. */\n            }\n\n            if (ctx.action == Gdk.DragAction.MOVE) {\n                delete_selection_data = true;\n            }\n            var source = Gtk.drag_get_source_widget(ctx);\n\n            print(\"Browser: source.DRAGDATA? \" + source.dragData);\n            if (this.targetData) {\n                print(this.targetData);\n                this.get('/LeftTree.model').dropNode(this.targetData,  source.dragData);\n            }\n            \n            \n            \n            dnd_success = true;\n\n        }\n\n        if (dnd_success == false)\n        {\n                Seed.print (\"DnD data transfer failed!\\n\");\n        }\n        \n        Gtk.drag_finish (ctx, dnd_success, delete_selection_data, time);\n        return true;\n    }",
                                "create_web_view": "function (self, object) {\n  print(\"CREATE WEB VIEW\");\n   return null; //new WebKit.WebView();\n}"
                            },
                            "id": "view",
                            "pack": "add",
                            "redraws": 0,
                            "xtype": "WebView",
                            "|init": "function() {\n    XObject.prototype.init.call(this);\n    // this may not work!?\n    var settings =  this.el.get_settings();\n    settings.enable_developer_extras = true;\n    \n    // this was an attempt to change the url perms.. did not work..\n    // settings.enable_file_access_from_file_uris = true;\n    // settings.enable_offline_web_application_cache - true;\n    // settings.enable_universal_access_from_file_uris = true;\n    var _this = this;\n     \n     // init inspector..\n    this.el.get_inspector().signal.inspect_web_view.connect(function(wi, pg) {\n         _this.get('/BottomPane.inspector').el.show();\n         return _this.get('/BottomPane.inspector').el;\n    \n    });\n     \n     // FIXME - base url of script..\n     // we need it so some of the database features work.\n    this.el.load_html_string( \"Render not ready\" , \n            //fixme - should be a config option!\n            // or should we catch stuff and fix it up..\n            'http://localhost/app.Builder/'\n    );\n        \n        \n   //this.el.open('file:///' + __script_path__ + '/../builder.html');\n                          \n    Gtk.drag_dest_set\n    (\n            this.el,              /* widget that will accept a drop */\n            Gtk.DestDefaults.MOTION  | Gtk.DestDefaults.HIGHLIGHT,\n            null,            /* lists of target to support */\n            0,              /* size of list */\n            Gdk.DragAction.COPY         /* what to do with data after dropped */\n    );\n                            \n   // print(\"RB: TARGETS : \" + LeftTree.atoms[\"STRING\"]);\n    Gtk.drag_dest_set_target_list(this.el, this.get('/Window').targetList);\n    \n    GLib.timeout_add_seconds(0, 1, function() {\n        //    print(\"run refresh?\");\n         _this.runRefresh(); \n         return true;\n     });\n    \n    \n}\n",
                            "|renderJS": "function(data, force) {\n\n    // this is the public redraw call..\n    // we refresh in a loop privately..\n    var autodraw = this.get('/RightBrowser.AutoRedraw').el.active;\n    if (!autodraw && !force) {\n        print(\"Skipping redraw - no force, and autodraw off\");\n        return;\n    }\n    this.refreshRequired  = true;\n}\n",
                            "|runRefresh": "function() \n{\n    // this is run every 2 seconds from the init..\n\n  \n    \n    if (!this.refreshRequired) {\n       // print(\"no refresh required\");\n        return;\n    }\n\n    if (this.lastRedraw) {\n       // do not redraw if last redraw was less that 5 seconds ago.\n       if (((new Date()) -  this.lastRedraw) < 5000) {\n            return;\n        }\n    }\n    \n    \n    \n    \n     if (!this.get('/Window.LeftTree').getActiveFile()) {\n        return;\n     }\n     this.refreshRequired = false;\n   //  print(\"HTML RENDERING\");\n     \n     this.get('/BottomPane').el.show();\n     this.get('/BottomPane').el.set_current_page(2);// webkit inspector\n\n    \n    var js = this.get('/LeftTree.model').toJS();\n    if (!js || !js.length) {\n        print(\"no data\");\n        return;\n    }\n    var  data = js[0];\n    this.redraws++;\n    \n     var project = this.get('/Window.LeftTree').getActiveFile().project;\n     //print (project.fn);\n     // set it to non-empty.\n     project.runhtml  =     project.runhtml  || '';\n     project.runhtml  = project.runhtml.length ?  project.runhtml : '<script type=\"text/javascript\"></script>'; \n    \n\n     this.runhtml  = this.runhtml || '';\n    \n     if ((project.runhtml != this.runhtml) || (this.redraws > 10)) {\n        // then we need to reload the browser using\n        // load_html_string..\n        \n        // then trigger a redraw once it's loaded..\n        this.pendingRedraw = true;\n         var runhtml = '<script type=\"text/javascript\">' + \"\\n\" ;\n         runhtml +=imports.File.File.read(__script_path__ + '/../builder.html.js') + \"\\n\";\n         runhtml += '</script>'+ \"\\n\" ;\n        \n        this.runhtml = project.runhtml;\n        // need to modify paths\n        \n        \n        \n        var html = imports.File.File.read(__script_path__ + '/../builder.html');\n        html = html.replace('</head>', runhtml + this.runhtml + '</head>');\n        print(\"LOAD HTML \" + html);\n        this.el.load_html_string( html , \n            //fixme - should be a config option!\n            'http://localhost/app.Builder/'\n        );\n        this.redraws = 0;\n        // should trigger load_finished! - which in truns shoudl set refresh Required;\n        return;\n    \n    }\n    \n    \n    this.renderedData = data;\n    var str = JSON.stringify(data) ;\n    \n    if (!this.ready) {\n        console.log('not loaded yet');\n    }\n    this.lastRedraw = new Date();\n\n    this.el.execute_script(\"Builder.render(\" + JSON.stringify(data) + \");\");\n     print( \"before render\" +    this.lastRedraw);\n    print( \"after render\" +    (new Date()));\n    \n}\n",
                            "|xns": "WebKit"
                        }
                    ]
                }
            ]
        }
    ],
    "permname": "",
    "modOrder": ""
}