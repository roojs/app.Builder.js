/* Node.vala.c generated by valac 0.20.1, the Vala compiler
 * generated from Node.vala, do not modify */

/* test..*/
/* valac gitlive/app.Builder.js/JsRender/Lang.vala gitlive/app.Builder.js/JsRender/Node.vala --pkg gee-1.0 --pkg=json-glib-1.0 -o /tmp/Lang ;/tmp/Lang*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <json-glib/json-glib.h>
#include <gobject/gvaluecollector.h>


#define JS_RENDER_TYPE_NODE (js_render_node_get_type ())
#define JS_RENDER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JS_RENDER_TYPE_NODE, JsRenderNode))
#define JS_RENDER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JS_RENDER_TYPE_NODE, JsRenderNodeClass))
#define JS_RENDER_IS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JS_RENDER_TYPE_NODE))
#define JS_RENDER_IS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JS_RENDER_TYPE_NODE))
#define JS_RENDER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JS_RENDER_TYPE_NODE, JsRenderNodeClass))

typedef struct _JsRenderNode JsRenderNode;
typedef struct _JsRenderNodeClass JsRenderNodeClass;
typedef struct _JsRenderNodePrivate JsRenderNodePrivate;
#define __g_list_free__js_render_node_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__js_render_node_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _js_render_node_unref0(var) ((var == NULL) ? NULL : (var = (js_render_node_unref (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define JS_RENDER_TYPE_LANGCLASS (js_render_langclass_get_type ())
#define JS_RENDER_LANGCLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JS_RENDER_TYPE_LANGCLASS, JsRenderLang_Class))
#define JS_RENDER_LANGCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JS_RENDER_TYPE_LANGCLASS, JsRenderLang_ClassClass))
#define JS_RENDER_IS_LANGCLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JS_RENDER_TYPE_LANGCLASS))
#define JS_RENDER_IS_LANGCLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JS_RENDER_TYPE_LANGCLASS))
#define JS_RENDER_LANGCLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JS_RENDER_TYPE_LANGCLASS, JsRenderLang_ClassClass))

typedef struct _JsRenderLang_Class JsRenderLang_Class;
typedef struct _JsRenderLang_ClassClass JsRenderLang_ClassClass;
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
typedef struct _JsRenderParamSpecNode JsRenderParamSpecNode;

struct _JsRenderNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	JsRenderNodePrivate * priv;
	gboolean is_array;
};

struct _JsRenderNodeClass {
	GTypeClass parent_class;
	void (*finalize) (JsRenderNode *self);
};

struct _JsRenderNodePrivate {
	GList* items;
	GeeHashMap* props;
};

struct _JsRenderParamSpecNode {
	GParamSpec parent_instance;
};


static gpointer js_render_node_parent_class = NULL;
static JsonGenerator* js_render_node_gen;
static JsonGenerator* js_render_node_gen = NULL;
extern JsRenderLang_Class* js_render_Lang;

gpointer js_render_node_ref (gpointer instance);
void js_render_node_unref (gpointer instance);
GParamSpec* js_render_param_spec_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void js_render_value_set_node (GValue* value, gpointer v_object);
void js_render_value_take_node (GValue* value, gpointer v_object);
gpointer js_render_value_get_node (const GValue* value);
GType js_render_node_get_type (void) G_GNUC_CONST;
#define JS_RENDER_NODE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), JS_RENDER_TYPE_NODE, JsRenderNodePrivate))
enum  {
	JS_RENDER_NODE_DUMMY_PROPERTY
};
static void _js_render_node_unref0_ (gpointer var);
static void _g_list_free__js_render_node_unref0_ (GList* self);
static JsRenderNode* js_render_node_new (void);
static JsRenderNode* js_render_node_construct (GType object_type);
gboolean js_render_node_isArray (JsRenderNode* self);
gboolean js_render_node_hasChildren (JsRenderNode* self);
gboolean js_render_node_hasXnsType (JsRenderNode* self);
gchar* js_render_node_get (JsRenderNode* self, const gchar* key);
gchar* js_render_node_mungeToString (JsRenderNode* self, gboolean isListener, const gchar* pad, GList* doubleStringProps);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
GType js_render_langclass_get_type (void) G_GNUC_CONST;
gboolean js_render_langclass_isKeyword (JsRenderLang_Class* self, const gchar* word);
gboolean js_render_langclass_isBuiltin (JsRenderLang_Class* self, const gchar* name);
gchar* js_render_node_quoteString (JsRenderNode* self, const gchar* str);
gboolean js_render_langclass_isNumber (JsRenderLang_Class* self, const gchar* str);
gboolean js_render_langclass_isBoolean (JsRenderLang_Class* self, const gchar* str);
static void _vala_JsonNode_free (JsonNode* self);
static void js_render_node_finalize (JsRenderNode* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void _js_render_node_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (js_render_node_unref (var), NULL));
}


static void _g_list_free__js_render_node_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _js_render_node_unref0_, NULL);
	g_list_free (self);
}


static JsRenderNode* js_render_node_construct (GType object_type) {
	JsRenderNode* self = NULL;
	GeeHashMap* _tmp0_;
	self = (JsRenderNode*) g_type_create_instance (object_type);
	__g_list_free__js_render_node_unref0_0 (self->priv->items);
	self->priv->items = NULL;
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->props);
	self->priv->props = _tmp0_;
	self->is_array = FALSE;
	return self;
}


static JsRenderNode* js_render_node_new (void) {
	return js_render_node_construct (JS_RENDER_TYPE_NODE);
}


gboolean js_render_node_isArray (JsRenderNode* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->is_array;
	result = _tmp0_;
	return result;
}


gboolean js_render_node_hasChildren (JsRenderNode* self) {
	gboolean result = FALSE;
	GList* _tmp0_;
	guint _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->items;
	_tmp1_ = g_list_length (_tmp0_);
	result = _tmp1_ > ((guint) 0);
	return result;
}


gboolean js_render_node_hasXnsType (JsRenderNode* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GeeHashMap* _tmp1_;
	gpointer _tmp2_ = NULL;
	gchar* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->priv->props;
	_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp1_, "|xns");
	_tmp3_ = (gchar*) _tmp2_;
	_tmp4_ = _tmp3_ != NULL;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		GeeHashMap* _tmp5_;
		gpointer _tmp6_ = NULL;
		gchar* _tmp7_;
		_tmp5_ = self->priv->props;
		_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, "xtype");
		_tmp7_ = (gchar*) _tmp6_;
		_tmp0_ = _tmp7_ != NULL;
		_g_free0 (_tmp7_);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp8_ = _tmp0_;
	if (_tmp8_) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


gchar* js_render_node_get (JsRenderNode* self, const gchar* key) {
	gchar* result = NULL;
	GeeHashMap* _tmp0_;
	const gchar* _tmp1_;
	gpointer _tmp2_ = NULL;
	gchar* k;
	const gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = self->priv->props;
	_tmp1_ = key;
	_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, _tmp1_);
	k = (gchar*) _tmp2_;
	_tmp3_ = k;
	if (_tmp3_ == NULL) {
		gchar* _tmp4_;
		_tmp4_ = g_strdup ("");
		result = _tmp4_;
		_g_free0 (k);
		return result;
	}
	result = k;
	return result;
}


static gpointer _js_render_node_ref0 (gpointer self) {
	return self ? js_render_node_ref (self) : NULL;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


gchar* js_render_node_mungeToString (JsRenderNode* self, gboolean isListener, const gchar* pad, GList* doubleStringProps) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean isArray;
	GList* els;
	GeeArrayList* _tmp7_;
	GeeArrayList* skip;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	gboolean _tmp11_;
	GeeHashMap* _tmp14_;
	GeeHashMap* oprops;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_;
	gboolean _tmp18_;
	gboolean _tmp58_ = FALSE;
	gchar* left = NULL;
	GRegex* func_regex = NULL;
	GeeHashMap* _tmp106_;
	GeeMapIterator* _tmp107_ = NULL;
	GeeMapIterator* piter;
	GeeHashMap* _tmp247_;
	GeeMapIterator* _tmp248_ = NULL;
	GeeMapIterator* iter;
	GList* _tmp309_;
	guint _tmp310_ = 0U;
	const gchar* _tmp312_;
	const gchar* _tmp313_;
	gint _tmp314_;
	gint _tmp315_;
	gchar* _tmp316_ = NULL;
	gchar* spad;
	const gchar* _tmp317_;
	gchar* _tmp318_;
	gchar* _tmp319_;
	const gchar* _tmp320_;
	gchar* _tmp321_;
	gchar* _tmp322_;
	GList* _tmp323_;
	gchar* _tmp324_ = NULL;
	gchar* _tmp325_;
	gchar* _tmp326_;
	gchar* _tmp327_;
	gchar* _tmp328_;
	gchar* _tmp329_;
	const gchar* _tmp330_;
	gchar* _tmp331_;
	gchar* _tmp332_;
	gchar* _tmp333_;
	gchar* _tmp334_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (pad != NULL, NULL);
	_tmp1_ = pad;
	_tmp2_ = strlen (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ < 1) {
		_tmp0_ = "    ";
	} else {
		const gchar* _tmp4_;
		_tmp4_ = pad;
		_tmp0_ = _tmp4_;
	}
	_tmp5_ = _tmp0_;
	pad = _tmp5_;
	_tmp6_ = js_render_node_isArray (self);
	isArray = _tmp6_;
	els = NULL;
	_tmp7_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	skip = _tmp7_;
	_tmp9_ = isArray;
	if (!_tmp9_) {
		gboolean _tmp10_ = FALSE;
		_tmp10_ = js_render_node_hasXnsType (self);
		_tmp8_ = _tmp10_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp11_ = _tmp8_;
	if (_tmp11_) {
		GeeArrayList* _tmp12_;
		GeeArrayList* _tmp13_;
		_tmp12_ = skip;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp12_, "|xns");
		_tmp13_ = skip;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, "xtype");
	}
	_tmp14_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, JS_RENDER_TYPE_NODE, (GBoxedCopyFunc) js_render_node_ref, js_render_node_unref, NULL, NULL, NULL);
	oprops = _tmp14_;
	_tmp16_ = isArray;
	if (!_tmp16_) {
		gboolean _tmp17_ = FALSE;
		_tmp17_ = js_render_node_hasChildren (self);
		_tmp15_ = _tmp17_;
	} else {
		_tmp15_ = FALSE;
	}
	_tmp18_ = _tmp15_;
	if (_tmp18_) {
		{
			gint ii;
			ii = 0;
			{
				gboolean _tmp19_;
				_tmp19_ = TRUE;
				while (TRUE) {
					gboolean _tmp20_;
					gint _tmp22_;
					GList* _tmp23_;
					guint _tmp24_ = 0U;
					GList* _tmp25_;
					gint _tmp26_;
					gconstpointer _tmp27_ = NULL;
					JsRenderNode* _tmp28_;
					JsRenderNode* pl;
					JsRenderNode* _tmp29_;
					GeeHashMap* _tmp30_;
					gboolean _tmp31_ = FALSE;
					JsRenderNode* _tmp32_;
					gchar* _tmp33_ = NULL;
					gchar* prop;
					const gchar* _tmp34_;
					gboolean _tmp35_ = FALSE;
					const gchar* _tmp39_;
					gchar* _tmp40_ = NULL;
					GeeHashMap* _tmp41_;
					const gchar* _tmp42_;
					gboolean _tmp43_ = FALSE;
					GeeHashMap* _tmp48_;
					const gchar* _tmp49_;
					gpointer _tmp50_ = NULL;
					JsRenderNode* _tmp51_;
					GeeHashMap* _tmp52_;
					const gchar* _tmp53_;
					gpointer _tmp54_ = NULL;
					JsRenderNode* _tmp55_;
					JsRenderNode* _tmp56_;
					JsRenderNode* _tmp57_;
					_tmp20_ = _tmp19_;
					if (!_tmp20_) {
						gint _tmp21_;
						_tmp21_ = ii;
						ii = _tmp21_ + 1;
					}
					_tmp19_ = FALSE;
					_tmp22_ = ii;
					_tmp23_ = self->priv->items;
					_tmp24_ = g_list_length (_tmp23_);
					if (!(((guint) _tmp22_) < _tmp24_)) {
						break;
					}
					_tmp25_ = self->priv->items;
					_tmp26_ = ii;
					_tmp27_ = g_list_nth_data (_tmp25_, (guint) _tmp26_);
					_tmp28_ = _js_render_node_ref0 ((JsRenderNode*) _tmp27_);
					pl = _tmp28_;
					_tmp29_ = pl;
					_tmp30_ = _tmp29_->priv->props;
					_tmp31_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp30_, "*prop");
					if (!_tmp31_) {
						_js_render_node_unref0 (pl);
						continue;
					}
					_tmp32_ = pl;
					_tmp33_ = js_render_node_get (_tmp32_, "*prop");
					prop = _tmp33_;
					_tmp34_ = prop;
					_tmp35_ = g_regex_match_simple ("\\[\\]$", _tmp34_, 0, 0);
					if (!_tmp35_) {
						GeeHashMap* _tmp36_;
						const gchar* _tmp37_;
						JsRenderNode* _tmp38_;
						_tmp36_ = oprops;
						_tmp37_ = prop;
						_tmp38_ = pl;
						gee_abstract_map_set ((GeeAbstractMap*) _tmp36_, _tmp37_, _tmp38_);
						_g_free0 (prop);
						_js_render_node_unref0 (pl);
						continue;
					}
					_tmp39_ = prop;
					_tmp40_ = string_substring (_tmp39_, (glong) 0, (glong) (-2));
					_g_free0 (prop);
					prop = _tmp40_;
					_tmp41_ = oprops;
					_tmp42_ = prop;
					_tmp43_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp41_, _tmp42_);
					if (!_tmp43_) {
						JsRenderNode* _tmp44_;
						JsRenderNode* cn;
						GeeHashMap* _tmp45_;
						const gchar* _tmp46_;
						JsRenderNode* _tmp47_;
						_tmp44_ = js_render_node_new ();
						cn = _tmp44_;
						_tmp45_ = oprops;
						_tmp46_ = prop;
						_tmp47_ = cn;
						gee_abstract_map_set ((GeeAbstractMap*) _tmp45_, _tmp46_, _tmp47_);
						_js_render_node_unref0 (cn);
					}
					_tmp48_ = oprops;
					_tmp49_ = prop;
					_tmp50_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp48_, _tmp49_);
					_tmp51_ = (JsRenderNode*) _tmp50_;
					_tmp51_->is_array = TRUE;
					_js_render_node_unref0 (_tmp51_);
					_tmp52_ = oprops;
					_tmp53_ = prop;
					_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp52_, _tmp53_);
					_tmp55_ = (JsRenderNode*) _tmp54_;
					_tmp56_ = pl;
					_tmp57_ = _js_render_node_ref0 (_tmp56_);
					_tmp55_->priv->items = g_list_append (_tmp55_->priv->items, _tmp57_);
					_js_render_node_unref0 (_tmp55_);
					_g_free0 (prop);
					_js_render_node_unref0 (pl);
				}
			}
		}
	}
	_tmp58_ = js_render_node_isArray (self);
	if (_tmp58_) {
		const gchar* _tmp80_;
		const gchar* _tmp81_;
		gint _tmp82_;
		gint _tmp83_;
		gchar* _tmp84_ = NULL;
		gchar* spad;
		const gchar* _tmp85_;
		gchar* _tmp86_;
		gchar* _tmp87_;
		const gchar* _tmp88_;
		gchar* _tmp89_;
		gchar* _tmp90_;
		GList* _tmp91_;
		gchar* _tmp92_ = NULL;
		gchar* _tmp93_;
		gchar* _tmp94_;
		gchar* _tmp95_;
		gchar* _tmp96_;
		gchar* _tmp97_;
		const gchar* _tmp98_;
		gchar* _tmp99_;
		gchar* _tmp100_;
		gchar* _tmp101_;
		gchar* _tmp102_;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp59_;
				_tmp59_ = TRUE;
				while (TRUE) {
					gboolean _tmp60_;
					gint _tmp62_;
					GList* _tmp63_;
					guint _tmp64_ = 0U;
					GList* _tmp65_;
					gint _tmp66_;
					gconstpointer _tmp67_ = NULL;
					JsRenderNode* _tmp68_;
					JsRenderNode* el;
					gint _tmp69_;
					gchar* _tmp70_ = NULL;
					gchar* _tmp71_;
					gchar* _tmp72_;
					gchar* _tmp73_;
					JsRenderNode* _tmp74_;
					const gchar* _tmp75_;
					GList* _tmp76_;
					gchar* _tmp77_ = NULL;
					gchar* _tmp78_;
					gchar* _tmp79_;
					_tmp60_ = _tmp59_;
					if (!_tmp60_) {
						gint _tmp61_;
						_tmp61_ = i;
						i = _tmp61_ + 1;
					}
					_tmp59_ = FALSE;
					_tmp62_ = i;
					_tmp63_ = self->priv->items;
					_tmp64_ = g_list_length (_tmp63_);
					if (!(((guint) _tmp62_) < _tmp64_)) {
						break;
					}
					_tmp65_ = self->priv->items;
					_tmp66_ = i;
					_tmp67_ = g_list_nth_data (_tmp65_, (guint) _tmp66_);
					_tmp68_ = _js_render_node_ref0 ((JsRenderNode*) _tmp67_);
					el = _tmp68_;
					_tmp69_ = i;
					_tmp70_ = g_strdup_printf ("%d", _tmp69_);
					_tmp71_ = _tmp70_;
					_tmp72_ = g_strconcat (_tmp71_, " : ", NULL);
					_tmp73_ = _tmp72_;
					_tmp74_ = el;
					_tmp75_ = pad;
					_tmp76_ = doubleStringProps;
					_tmp77_ = js_render_node_mungeToString (_tmp74_, FALSE, _tmp75_, _tmp76_);
					_tmp78_ = _tmp77_;
					_tmp79_ = g_strconcat (_tmp73_, _tmp78_, NULL);
					els = g_list_append (els, _tmp79_);
					_g_free0 (_tmp78_);
					_g_free0 (_tmp73_);
					_g_free0 (_tmp71_);
					_js_render_node_unref0 (el);
				}
			}
		}
		_tmp80_ = pad;
		_tmp81_ = pad;
		_tmp82_ = strlen (_tmp81_);
		_tmp83_ = _tmp82_;
		_tmp84_ = string_substring (_tmp80_, (glong) 0, (glong) (_tmp83_ - 4));
		spad = _tmp84_;
		_tmp85_ = pad;
		_tmp86_ = g_strconcat ("{\n", _tmp85_, NULL);
		_tmp87_ = _tmp86_;
		_tmp88_ = pad;
		_tmp89_ = g_strconcat (",\n", _tmp88_, NULL);
		_tmp90_ = _tmp89_;
		_tmp91_ = els;
		_tmp92_ = g_strjoin (_tmp90_, _tmp91_, NULL);
		_tmp93_ = _tmp92_;
		_tmp94_ = g_strconcat (_tmp87_, _tmp93_, NULL);
		_tmp95_ = _tmp94_;
		_tmp96_ = g_strconcat (_tmp95_, "\n", NULL);
		_tmp97_ = _tmp96_;
		_tmp98_ = spad;
		_tmp99_ = g_strconcat (_tmp97_, _tmp98_, NULL);
		_tmp100_ = _tmp99_;
		_tmp101_ = g_strconcat (_tmp100_, "}", NULL);
		_tmp102_ = _tmp101_;
		_g_free0 (_tmp100_);
		_g_free0 (_tmp97_);
		_g_free0 (_tmp95_);
		_g_free0 (_tmp93_);
		_g_free0 (_tmp90_);
		_g_free0 (_tmp87_);
		result = _tmp102_;
		_g_free0 (spad);
		_g_object_unref0 (oprops);
		_g_object_unref0 (skip);
		__g_list_free__g_free0_0 (els);
		return result;
	}
	{
		GRegex* _tmp103_;
		GRegex* _tmp104_;
		_tmp103_ = g_regex_new ("^\\s+|\\s+$", 0, 0, &_inner_error_);
		_tmp104_ = _tmp103_;
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_g_regex_unref0 (func_regex);
		func_regex = _tmp104_;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		gchar* _tmp105_;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_print ("failed to build regex");
		_tmp105_ = g_strdup ("");
		result = _tmp105_;
		_g_error_free0 (e);
		_g_regex_unref0 (func_regex);
		_g_free0 (left);
		_g_object_unref0 (oprops);
		_g_object_unref0 (skip);
		__g_list_free__g_free0_0 (els);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (func_regex);
		_g_free0 (left);
		_g_object_unref0 (oprops);
		_g_object_unref0 (skip);
		__g_list_free__g_free0_0 (els);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp106_ = self->priv->props;
	_tmp107_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp106_);
	piter = _tmp107_;
	while (TRUE) {
		GeeMapIterator* _tmp108_;
		gboolean _tmp109_ = FALSE;
		GeeMapIterator* _tmp110_;
		gpointer _tmp111_ = NULL;
		gchar* k;
		GeeMapIterator* _tmp112_;
		gpointer _tmp113_ = NULL;
		gchar* v;
		GeeArrayList* _tmp114_;
		const gchar* _tmp115_;
		gboolean _tmp116_ = FALSE;
		gchar* _tmp117_ = NULL;
		const gchar* _tmp118_;
		gchar _tmp119_ = '\0';
		const gchar* _tmp124_;
		gchar* _tmp125_;
		gchar* leftv;
		const gchar* _tmp126_;
		gchar _tmp127_ = '\0';
		const gchar* _tmp128_;
		gchar _tmp129_ = '\0';
		gboolean _tmp130_ = FALSE;
		JsRenderLang_Class* _tmp131_;
		const gchar* _tmp132_;
		gboolean _tmp133_ = FALSE;
		gboolean _tmp137_;
		const gchar* _tmp159_;
		gchar* _tmp160_;
		gboolean _tmp161_;
		const gchar* _tmp182_;
		gchar _tmp183_ = '\0';
		gboolean _tmp207_ = FALSE;
		JsRenderLang_Class* _tmp208_;
		const gchar* _tmp209_;
		gboolean _tmp210_ = FALSE;
		gboolean _tmp214_;
		GList* _tmp218_;
		guint _tmp219_ = 0U;
		GList* _tmp225_;
		const gchar* _tmp226_;
		gint _tmp227_ = 0;
		const gchar* _tmp233_;
		gchar* _tmp234_;
		gchar* _tmp235_;
		const gchar* _tmp236_;
		const gchar* _tmp237_;
		gint _tmp238_;
		gint _tmp239_;
		gchar* _tmp240_ = NULL;
		gchar* _tmp241_;
		gchar* _tmp242_ = NULL;
		gchar* _tmp243_;
		gchar* _tmp244_;
		gchar* _tmp245_;
		gchar* _tmp246_;
		_tmp108_ = piter;
		_tmp109_ = gee_map_iterator_next (_tmp108_);
		if (!_tmp109_) {
			break;
		}
		_tmp110_ = piter;
		_tmp111_ = gee_map_iterator_get_key (_tmp110_);
		k = (gchar*) _tmp111_;
		_tmp112_ = piter;
		_tmp113_ = gee_map_iterator_get_value (_tmp112_);
		v = (gchar*) _tmp113_;
		_tmp114_ = skip;
		_tmp115_ = k;
		_tmp116_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp114_, _tmp115_);
		if (_tmp116_) {
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp118_ = k;
		_tmp119_ = string_get (_tmp118_, (glong) 0);
		if (_tmp119_ == '|') {
			const gchar* _tmp120_;
			gchar* _tmp121_ = NULL;
			_tmp120_ = k;
			_tmp121_ = string_substring (_tmp120_, (glong) 1, (glong) (-1));
			_g_free0 (_tmp117_);
			_tmp117_ = _tmp121_;
		} else {
			const gchar* _tmp122_;
			gchar* _tmp123_;
			_tmp122_ = k;
			_tmp123_ = g_strdup (_tmp122_);
			_g_free0 (_tmp117_);
			_tmp117_ = _tmp123_;
		}
		_tmp124_ = _tmp117_;
		_tmp125_ = g_strdup (_tmp124_);
		leftv = _tmp125_;
		_tmp126_ = leftv;
		_tmp127_ = string_get (_tmp126_, (glong) 0);
		if (_tmp127_ == '.') {
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp128_ = k;
		_tmp129_ = string_get (_tmp128_, (glong) 0);
		if (_tmp129_ == '*') {
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp131_ = js_render_Lang;
		_tmp132_ = leftv;
		_tmp133_ = js_render_langclass_isKeyword (_tmp131_, _tmp132_);
		if (_tmp133_) {
			_tmp130_ = TRUE;
		} else {
			JsRenderLang_Class* _tmp134_;
			const gchar* _tmp135_;
			gboolean _tmp136_ = FALSE;
			_tmp134_ = js_render_Lang;
			_tmp135_ = leftv;
			_tmp136_ = js_render_langclass_isBuiltin (_tmp134_, _tmp135_);
			_tmp130_ = _tmp136_;
		}
		_tmp137_ = _tmp130_;
		if (_tmp137_) {
			const gchar* _tmp138_;
			gchar* _tmp139_;
			gchar* _tmp140_;
			gchar* _tmp141_;
			_tmp138_ = leftv;
			_tmp139_ = g_strconcat ("'", _tmp138_, NULL);
			_tmp140_ = _tmp139_;
			_tmp141_ = g_strconcat (_tmp140_, "'", NULL);
			_g_free0 (left);
			left = _tmp141_;
			_g_free0 (_tmp140_);
		} else {
			const gchar* _tmp142_;
			gboolean _tmp143_ = FALSE;
			_tmp142_ = leftv;
			_tmp143_ = g_regex_match_simple ("[^A-Za-z_]+", _tmp142_, 0, 0);
			if (_tmp143_) {
				const gchar* _tmp144_;
				gchar* _tmp145_ = NULL;
				gchar* val;
				const gchar* _tmp146_;
				const gchar* _tmp147_;
				gint _tmp148_;
				gint _tmp149_;
				gchar* _tmp150_ = NULL;
				gchar* _tmp151_;
				gchar* _tmp152_ = NULL;
				gchar* _tmp153_;
				gchar* _tmp154_;
				gchar* _tmp155_;
				gchar* _tmp156_;
				_tmp144_ = leftv;
				_tmp145_ = js_render_node_quoteString (self, _tmp144_);
				val = _tmp145_;
				_tmp146_ = val;
				_tmp147_ = val;
				_tmp148_ = strlen (_tmp147_);
				_tmp149_ = _tmp148_;
				_tmp150_ = string_substring (_tmp146_, (glong) 1, (glong) (_tmp149_ - 1));
				_tmp151_ = _tmp150_;
				_tmp152_ = string_replace (_tmp151_, "'", "\\'");
				_tmp153_ = _tmp152_;
				_tmp154_ = g_strconcat ("'", _tmp153_, NULL);
				_tmp155_ = _tmp154_;
				_tmp156_ = g_strconcat (_tmp155_, "'", NULL);
				_g_free0 (left);
				left = _tmp156_;
				_g_free0 (_tmp155_);
				_g_free0 (_tmp153_);
				_g_free0 (_tmp151_);
				_g_free0 (val);
			} else {
				const gchar* _tmp157_;
				gchar* _tmp158_;
				_tmp157_ = leftv;
				_tmp158_ = g_strdup (_tmp157_);
				_g_free0 (left);
				left = _tmp158_;
			}
		}
		_tmp159_ = left;
		_tmp160_ = g_strconcat (_tmp159_, " : ", NULL);
		_g_free0 (left);
		left = _tmp160_;
		_tmp161_ = isListener;
		if (_tmp161_) {
			gchar* str = NULL;
			const gchar* _tmp170_;
			gchar** _tmp171_;
			gchar** _tmp172_ = NULL;
			gchar** lines;
			gint lines_length1;
			gint _lines_size_;
			gchar** _tmp173_;
			gint _tmp173__length1;
			const gchar* _tmp179_;
			const gchar* _tmp180_;
			gchar* _tmp181_;
			{
				GRegex* _tmp162_;
				const gchar* _tmp163_;
				const gchar* _tmp164_;
				gint _tmp165_;
				gint _tmp166_;
				gchar* _tmp167_ = NULL;
				gchar* _tmp168_;
				_tmp162_ = func_regex;
				_tmp163_ = v;
				_tmp164_ = v;
				_tmp165_ = strlen (_tmp164_);
				_tmp166_ = _tmp165_;
				_tmp167_ = g_regex_replace (_tmp162_, _tmp163_, (gssize) _tmp166_, 0, "", 0, &_inner_error_);
				_tmp168_ = _tmp167_;
				if (_inner_error_ != NULL) {
					goto __catch2_g_error;
				}
				_g_free0 (str);
				str = _tmp168_;
			}
			goto __finally2;
			__catch2_g_error:
			{
				GError* e = NULL;
				gchar* _tmp169_;
				e = _inner_error_;
				_inner_error_ = NULL;
				g_print ("regex failed");
				_tmp169_ = g_strdup ("");
				result = _tmp169_;
				_g_error_free0 (e);
				_g_free0 (str);
				_g_free0 (leftv);
				_g_free0 (_tmp117_);
				_g_free0 (v);
				_g_free0 (k);
				_g_object_unref0 (piter);
				_g_regex_unref0 (func_regex);
				_g_free0 (left);
				_g_object_unref0 (oprops);
				_g_object_unref0 (skip);
				__g_list_free__g_free0_0 (els);
				return result;
			}
			__finally2:
			if (_inner_error_ != NULL) {
				_g_free0 (str);
				_g_free0 (leftv);
				_g_free0 (_tmp117_);
				_g_free0 (v);
				_g_free0 (k);
				_g_object_unref0 (piter);
				_g_regex_unref0 (func_regex);
				_g_free0 (left);
				_g_object_unref0 (oprops);
				_g_object_unref0 (skip);
				__g_list_free__g_free0_0 (els);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_tmp170_ = str;
			_tmp172_ = _tmp171_ = g_strsplit (_tmp170_, "\n", 0);
			lines = _tmp172_;
			lines_length1 = _vala_array_length (_tmp171_);
			_lines_size_ = lines_length1;
			_tmp173_ = lines;
			_tmp173__length1 = lines_length1;
			if (_tmp173__length1 > 1) {
				const gchar* _tmp174_;
				gchar* _tmp175_;
				gchar* _tmp176_;
				gchar** _tmp177_;
				gint _tmp177__length1;
				gchar* _tmp178_ = NULL;
				_tmp174_ = pad;
				_tmp175_ = g_strconcat ("\n", _tmp174_, NULL);
				_tmp176_ = _tmp175_;
				_tmp177_ = lines;
				_tmp177__length1 = lines_length1;
				_tmp178_ = g_strjoin (_tmp176_, _tmp177_, NULL);
				_g_free0 (str);
				str = _tmp178_;
				_g_free0 (_tmp176_);
			}
			_tmp179_ = left;
			_tmp180_ = str;
			_tmp181_ = g_strconcat (_tmp179_, _tmp180_, NULL);
			els = g_list_append (els, _tmp181_);
			lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (str);
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp182_ = k;
		_tmp183_ = string_get (_tmp182_, (glong) 0);
		if (_tmp183_ == '|') {
			const gchar* _tmp184_;
			gint _tmp185_;
			gint _tmp186_;
			gchar* str = NULL;
			const gchar* _tmp195_;
			gchar** _tmp196_;
			gchar** _tmp197_ = NULL;
			gchar** lines;
			gint lines_length1;
			gint _lines_size_;
			gchar** _tmp198_;
			gint _tmp198__length1;
			const gchar* _tmp204_;
			const gchar* _tmp205_;
			gchar* _tmp206_;
			_tmp184_ = v;
			_tmp185_ = strlen (_tmp184_);
			_tmp186_ = _tmp185_;
			if (_tmp186_ < 1) {
				_g_free0 (leftv);
				_g_free0 (_tmp117_);
				_g_free0 (v);
				_g_free0 (k);
				continue;
			}
			{
				GRegex* _tmp187_;
				const gchar* _tmp188_;
				const gchar* _tmp189_;
				gint _tmp190_;
				gint _tmp191_;
				gchar* _tmp192_ = NULL;
				gchar* _tmp193_;
				_tmp187_ = func_regex;
				_tmp188_ = v;
				_tmp189_ = v;
				_tmp190_ = strlen (_tmp189_);
				_tmp191_ = _tmp190_;
				_tmp192_ = g_regex_replace (_tmp187_, _tmp188_, (gssize) _tmp191_, 0, "", 0, &_inner_error_);
				_tmp193_ = _tmp192_;
				if (_inner_error_ != NULL) {
					goto __catch3_g_error;
				}
				_g_free0 (str);
				str = _tmp193_;
			}
			goto __finally3;
			__catch3_g_error:
			{
				GError* e = NULL;
				gchar* _tmp194_;
				e = _inner_error_;
				_inner_error_ = NULL;
				g_print ("regex failed");
				_tmp194_ = g_strdup ("");
				result = _tmp194_;
				_g_error_free0 (e);
				_g_free0 (str);
				_g_free0 (leftv);
				_g_free0 (_tmp117_);
				_g_free0 (v);
				_g_free0 (k);
				_g_object_unref0 (piter);
				_g_regex_unref0 (func_regex);
				_g_free0 (left);
				_g_object_unref0 (oprops);
				_g_object_unref0 (skip);
				__g_list_free__g_free0_0 (els);
				return result;
			}
			__finally3:
			if (_inner_error_ != NULL) {
				_g_free0 (str);
				_g_free0 (leftv);
				_g_free0 (_tmp117_);
				_g_free0 (v);
				_g_free0 (k);
				_g_object_unref0 (piter);
				_g_regex_unref0 (func_regex);
				_g_free0 (left);
				_g_object_unref0 (oprops);
				_g_object_unref0 (skip);
				__g_list_free__g_free0_0 (els);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_tmp195_ = str;
			_tmp197_ = _tmp196_ = g_strsplit (_tmp195_, "\n", 0);
			lines = _tmp197_;
			lines_length1 = _vala_array_length (_tmp196_);
			_lines_size_ = lines_length1;
			_tmp198_ = lines;
			_tmp198__length1 = lines_length1;
			if (_tmp198__length1 > 1) {
				const gchar* _tmp199_;
				gchar* _tmp200_;
				gchar* _tmp201_;
				gchar** _tmp202_;
				gint _tmp202__length1;
				gchar* _tmp203_ = NULL;
				_tmp199_ = pad;
				_tmp200_ = g_strconcat ("\n", _tmp199_, NULL);
				_tmp201_ = _tmp200_;
				_tmp202_ = lines;
				_tmp202__length1 = lines_length1;
				_tmp203_ = g_strjoin (_tmp201_, _tmp202_, NULL);
				_g_free0 (str);
				str = _tmp203_;
				_g_free0 (_tmp201_);
			}
			_tmp204_ = left;
			_tmp205_ = str;
			_tmp206_ = g_strconcat (_tmp204_, _tmp205_, NULL);
			els = g_list_append (els, _tmp206_);
			lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (str);
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp208_ = js_render_Lang;
		_tmp209_ = v;
		_tmp210_ = js_render_langclass_isNumber (_tmp208_, _tmp209_);
		if (_tmp210_) {
			_tmp207_ = TRUE;
		} else {
			JsRenderLang_Class* _tmp211_;
			const gchar* _tmp212_;
			gboolean _tmp213_ = FALSE;
			_tmp211_ = js_render_Lang;
			_tmp212_ = v;
			_tmp213_ = js_render_langclass_isBoolean (_tmp211_, _tmp212_);
			_tmp207_ = _tmp213_;
		}
		_tmp214_ = _tmp207_;
		if (_tmp214_) {
			const gchar* _tmp215_;
			const gchar* _tmp216_;
			gchar* _tmp217_;
			_tmp215_ = left;
			_tmp216_ = v;
			_tmp217_ = g_strconcat (_tmp215_, _tmp216_, NULL);
			els = g_list_append (els, _tmp217_);
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp218_ = doubleStringProps;
		_tmp219_ = g_list_length (_tmp218_);
		if (_tmp219_ < ((guint) 1)) {
			const gchar* _tmp220_;
			const gchar* _tmp221_;
			gchar* _tmp222_ = NULL;
			gchar* _tmp223_;
			gchar* _tmp224_;
			_tmp220_ = left;
			_tmp221_ = v;
			_tmp222_ = js_render_node_quoteString (self, _tmp221_);
			_tmp223_ = _tmp222_;
			_tmp224_ = g_strconcat (_tmp220_, _tmp223_, NULL);
			els = g_list_append (els, _tmp224_);
			_g_free0 (_tmp223_);
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp225_ = doubleStringProps;
		_tmp226_ = k;
		_tmp227_ = g_list_index (_tmp225_, _tmp226_);
		if (_tmp227_ > (-1)) {
			const gchar* _tmp228_;
			const gchar* _tmp229_;
			gchar* _tmp230_ = NULL;
			gchar* _tmp231_;
			gchar* _tmp232_;
			_tmp228_ = left;
			_tmp229_ = v;
			_tmp230_ = js_render_node_quoteString (self, _tmp229_);
			_tmp231_ = _tmp230_;
			_tmp232_ = g_strconcat (_tmp228_, _tmp231_, NULL);
			els = g_list_append (els, _tmp232_);
			_g_free0 (_tmp231_);
			_g_free0 (leftv);
			_g_free0 (_tmp117_);
			_g_free0 (v);
			_g_free0 (k);
			continue;
		}
		_tmp233_ = left;
		_tmp234_ = g_strconcat (_tmp233_, "'", NULL);
		_tmp235_ = _tmp234_;
		_tmp236_ = v;
		_tmp237_ = v;
		_tmp238_ = strlen (_tmp237_);
		_tmp239_ = _tmp238_;
		_tmp240_ = string_substring (_tmp236_, (glong) 1, (glong) (_tmp239_ - 1));
		_tmp241_ = _tmp240_;
		_tmp242_ = string_replace (_tmp241_, "'", "\\'");
		_tmp243_ = _tmp242_;
		_tmp244_ = g_strconcat (_tmp235_, _tmp243_, NULL);
		_tmp245_ = _tmp244_;
		_tmp246_ = g_strconcat (_tmp245_, "'", NULL);
		els = g_list_append (els, _tmp246_);
		_g_free0 (_tmp245_);
		_g_free0 (_tmp243_);
		_g_free0 (_tmp241_);
		_g_free0 (_tmp235_);
		_g_free0 (leftv);
		_g_free0 (_tmp117_);
		_g_free0 (v);
		_g_free0 (k);
	}
	_tmp247_ = oprops;
	_tmp248_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp247_);
	iter = _tmp248_;
	while (TRUE) {
		GeeMapIterator* _tmp249_;
		gboolean _tmp250_ = FALSE;
		GeeMapIterator* _tmp251_;
		gpointer _tmp252_ = NULL;
		gchar* k;
		GeeMapIterator* _tmp253_;
		gpointer _tmp254_ = NULL;
		JsRenderNode* vo;
		gchar* _tmp255_ = NULL;
		const gchar* _tmp256_;
		gchar _tmp257_ = '\0';
		const gchar* _tmp262_;
		gchar* _tmp263_;
		gchar* leftv;
		gboolean _tmp264_ = FALSE;
		JsRenderLang_Class* _tmp265_;
		const gchar* _tmp266_;
		gboolean _tmp267_ = FALSE;
		gboolean _tmp271_;
		const gchar* _tmp293_;
		gchar* _tmp294_;
		JsRenderNode* _tmp295_;
		const gchar* _tmp296_;
		const gchar* _tmp297_;
		gchar* _tmp298_;
		gchar* _tmp299_;
		GList* _tmp300_;
		gchar* _tmp301_ = NULL;
		gchar* _tmp302_;
		gchar* right;
		const gchar* _tmp303_;
		gint _tmp304_;
		gint _tmp305_;
		_tmp249_ = iter;
		_tmp250_ = gee_map_iterator_next (_tmp249_);
		if (!_tmp250_) {
			break;
		}
		_tmp251_ = iter;
		_tmp252_ = gee_map_iterator_get_key (_tmp251_);
		k = (gchar*) _tmp252_;
		_tmp253_ = iter;
		_tmp254_ = gee_map_iterator_get_value (_tmp253_);
		vo = (JsRenderNode*) _tmp254_;
		_tmp256_ = k;
		_tmp257_ = string_get (_tmp256_, (glong) 0);
		if (_tmp257_ == '|') {
			const gchar* _tmp258_;
			gchar* _tmp259_ = NULL;
			_tmp258_ = k;
			_tmp259_ = string_substring (_tmp258_, (glong) 1, (glong) (-1));
			_g_free0 (_tmp255_);
			_tmp255_ = _tmp259_;
		} else {
			const gchar* _tmp260_;
			gchar* _tmp261_;
			_tmp260_ = k;
			_tmp261_ = g_strdup (_tmp260_);
			_g_free0 (_tmp255_);
			_tmp255_ = _tmp261_;
		}
		_tmp262_ = _tmp255_;
		_tmp263_ = g_strdup (_tmp262_);
		leftv = _tmp263_;
		_tmp265_ = js_render_Lang;
		_tmp266_ = leftv;
		_tmp267_ = js_render_langclass_isKeyword (_tmp265_, _tmp266_);
		if (_tmp267_) {
			_tmp264_ = TRUE;
		} else {
			JsRenderLang_Class* _tmp268_;
			const gchar* _tmp269_;
			gboolean _tmp270_ = FALSE;
			_tmp268_ = js_render_Lang;
			_tmp269_ = leftv;
			_tmp270_ = js_render_langclass_isBuiltin (_tmp268_, _tmp269_);
			_tmp264_ = _tmp270_;
		}
		_tmp271_ = _tmp264_;
		if (_tmp271_) {
			const gchar* _tmp272_;
			gchar* _tmp273_;
			gchar* _tmp274_;
			gchar* _tmp275_;
			_tmp272_ = leftv;
			_tmp273_ = g_strconcat ("'", _tmp272_, NULL);
			_tmp274_ = _tmp273_;
			_tmp275_ = g_strconcat (_tmp274_, "'", NULL);
			_g_free0 (left);
			left = _tmp275_;
			_g_free0 (_tmp274_);
		} else {
			const gchar* _tmp276_;
			gboolean _tmp277_ = FALSE;
			_tmp276_ = leftv;
			_tmp277_ = g_regex_match_simple ("[^A-Za-z_]+", _tmp276_, 0, 0);
			if (_tmp277_) {
				const gchar* _tmp278_;
				gchar* _tmp279_ = NULL;
				gchar* val;
				const gchar* _tmp280_;
				const gchar* _tmp281_;
				gint _tmp282_;
				gint _tmp283_;
				gchar* _tmp284_ = NULL;
				gchar* _tmp285_;
				gchar* _tmp286_ = NULL;
				gchar* _tmp287_;
				gchar* _tmp288_;
				gchar* _tmp289_;
				gchar* _tmp290_;
				_tmp278_ = leftv;
				_tmp279_ = js_render_node_quoteString (self, _tmp278_);
				val = _tmp279_;
				_tmp280_ = val;
				_tmp281_ = val;
				_tmp282_ = strlen (_tmp281_);
				_tmp283_ = _tmp282_;
				_tmp284_ = string_substring (_tmp280_, (glong) 1, (glong) (_tmp283_ - 1));
				_tmp285_ = _tmp284_;
				_tmp286_ = string_replace (_tmp285_, "'", "\\'");
				_tmp287_ = _tmp286_;
				_tmp288_ = g_strconcat ("'", _tmp287_, NULL);
				_tmp289_ = _tmp288_;
				_tmp290_ = g_strconcat (_tmp289_, "'", NULL);
				_g_free0 (left);
				left = _tmp290_;
				_g_free0 (_tmp289_);
				_g_free0 (_tmp287_);
				_g_free0 (_tmp285_);
				_g_free0 (val);
			} else {
				const gchar* _tmp291_;
				gchar* _tmp292_;
				_tmp291_ = leftv;
				_tmp292_ = g_strdup (_tmp291_);
				_g_free0 (left);
				left = _tmp292_;
			}
		}
		_tmp293_ = left;
		_tmp294_ = g_strconcat (_tmp293_, " : ", NULL);
		_g_free0 (left);
		left = _tmp294_;
		_tmp295_ = vo;
		_tmp296_ = k;
		_tmp297_ = pad;
		_tmp298_ = g_strconcat (_tmp297_, "    ", NULL);
		_tmp299_ = _tmp298_;
		_tmp300_ = doubleStringProps;
		_tmp301_ = js_render_node_mungeToString (_tmp295_, g_strcmp0 (_tmp296_, "listeners") == 0, _tmp299_, _tmp300_);
		_tmp302_ = _tmp301_;
		_g_free0 (_tmp299_);
		right = _tmp302_;
		_tmp303_ = right;
		_tmp304_ = strlen (_tmp303_);
		_tmp305_ = _tmp304_;
		if (_tmp305_ > 0) {
			const gchar* _tmp306_;
			const gchar* _tmp307_;
			gchar* _tmp308_;
			_tmp306_ = left;
			_tmp307_ = right;
			_tmp308_ = g_strconcat (_tmp306_, _tmp307_, NULL);
			els = g_list_append (els, _tmp308_);
		}
		_g_free0 (right);
		_g_free0 (leftv);
		_g_free0 (_tmp255_);
		_js_render_node_unref0 (vo);
		_g_free0 (k);
	}
	_tmp309_ = els;
	_tmp310_ = g_list_length (_tmp309_);
	if (_tmp310_ < ((guint) 1)) {
		gchar* _tmp311_;
		_tmp311_ = g_strdup ("");
		result = _tmp311_;
		_g_object_unref0 (iter);
		_g_object_unref0 (piter);
		_g_regex_unref0 (func_regex);
		_g_free0 (left);
		_g_object_unref0 (oprops);
		_g_object_unref0 (skip);
		__g_list_free__g_free0_0 (els);
		return result;
	}
	_tmp312_ = pad;
	_tmp313_ = pad;
	_tmp314_ = strlen (_tmp313_);
	_tmp315_ = _tmp314_;
	_tmp316_ = string_substring (_tmp312_, (glong) 0, (glong) (_tmp315_ - 4));
	spad = _tmp316_;
	_tmp317_ = pad;
	_tmp318_ = g_strconcat ("{\n", _tmp317_, NULL);
	_tmp319_ = _tmp318_;
	_tmp320_ = pad;
	_tmp321_ = g_strconcat (",\n", _tmp320_, NULL);
	_tmp322_ = _tmp321_;
	_tmp323_ = els;
	_tmp324_ = g_strjoin (_tmp322_, _tmp323_, NULL);
	_tmp325_ = _tmp324_;
	_tmp326_ = g_strconcat (_tmp319_, _tmp325_, NULL);
	_tmp327_ = _tmp326_;
	_tmp328_ = g_strconcat (_tmp327_, "\n", NULL);
	_tmp329_ = _tmp328_;
	_tmp330_ = spad;
	_tmp331_ = g_strconcat (_tmp329_, _tmp330_, NULL);
	_tmp332_ = _tmp331_;
	_tmp333_ = g_strconcat (_tmp332_, "}", NULL);
	_tmp334_ = _tmp333_;
	_g_free0 (_tmp332_);
	_g_free0 (_tmp329_);
	_g_free0 (_tmp327_);
	_g_free0 (_tmp325_);
	_g_free0 (_tmp322_);
	_g_free0 (_tmp319_);
	result = _tmp334_;
	_g_free0 (spad);
	_g_object_unref0 (iter);
	_g_object_unref0 (piter);
	_g_regex_unref0 (func_regex);
	_g_free0 (left);
	_g_object_unref0 (oprops);
	_g_object_unref0 (skip);
	__g_list_free__g_free0_0 (els);
	return result;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


gchar* js_render_node_quoteString (JsRenderNode* self, const gchar* str) {
	gchar* result = NULL;
	JsonGenerator* _tmp0_;
	JsonBuilder* _tmp2_;
	JsonBuilder* builder;
	const gchar* _tmp3_;
	JsonGenerator* _tmp4_;
	JsonNode* _tmp5_ = NULL;
	JsonNode* _tmp6_;
	JsonGenerator* _tmp7_;
	gchar* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = js_render_node_gen;
	if (_tmp0_ == NULL) {
		JsonGenerator* _tmp1_;
		_tmp1_ = json_generator_new ();
		_g_object_unref0 (js_render_node_gen);
		js_render_node_gen = _tmp1_;
	}
	_tmp2_ = json_builder_new ();
	builder = _tmp2_;
	_tmp3_ = str;
	json_builder_add_string_value (builder, _tmp3_);
	_tmp4_ = js_render_node_gen;
	_tmp5_ = json_builder_get_root (builder);
	_tmp6_ = _tmp5_;
	json_generator_set_root (_tmp4_, _tmp6_);
	__vala_JsonNode_free0 (_tmp6_);
	_tmp7_ = js_render_node_gen;
	_tmp8_ = json_generator_to_data (_tmp7_, NULL);
	result = _tmp8_;
	_g_object_unref0 (builder);
	return result;
}


static void js_render_value_node_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void js_render_value_node_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		js_render_node_unref (value->data[0].v_pointer);
	}
}


static void js_render_value_node_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = js_render_node_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer js_render_value_node_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* js_render_value_node_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		JsRenderNode* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = js_render_node_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* js_render_value_node_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	JsRenderNode** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = js_render_node_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* js_render_param_spec_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	JsRenderParamSpecNode* spec;
	g_return_val_if_fail (g_type_is_a (object_type, JS_RENDER_TYPE_NODE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer js_render_value_get_node (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, JS_RENDER_TYPE_NODE), NULL);
	return value->data[0].v_pointer;
}


void js_render_value_set_node (GValue* value, gpointer v_object) {
	JsRenderNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, JS_RENDER_TYPE_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, JS_RENDER_TYPE_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		js_render_node_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		js_render_node_unref (old);
	}
}


void js_render_value_take_node (GValue* value, gpointer v_object) {
	JsRenderNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, JS_RENDER_TYPE_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, JS_RENDER_TYPE_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		js_render_node_unref (old);
	}
}


static void js_render_node_class_init (JsRenderNodeClass * klass) {
	js_render_node_parent_class = g_type_class_peek_parent (klass);
	JS_RENDER_NODE_CLASS (klass)->finalize = js_render_node_finalize;
	g_type_class_add_private (klass, sizeof (JsRenderNodePrivate));
}


static void js_render_node_instance_init (JsRenderNode * self) {
	self->priv = JS_RENDER_NODE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void js_render_node_finalize (JsRenderNode* obj) {
	JsRenderNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, JS_RENDER_TYPE_NODE, JsRenderNode);
	__g_list_free__js_render_node_unref0_0 (self->priv->items);
	_g_object_unref0 (self->priv->props);
}


GType js_render_node_get_type (void) {
	static volatile gsize js_render_node_type_id__volatile = 0;
	if (g_once_init_enter (&js_render_node_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { js_render_value_node_init, js_render_value_node_free_value, js_render_value_node_copy_value, js_render_value_node_peek_pointer, "p", js_render_value_node_collect_value, "p", js_render_value_node_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (JsRenderNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) js_render_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (JsRenderNode), 0, (GInstanceInitFunc) js_render_node_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType js_render_node_type_id;
		js_render_node_type_id = g_type_register_fundamental (g_type_fundamental_next (), "JsRenderNode", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&js_render_node_type_id__volatile, js_render_node_type_id);
	}
	return js_render_node_type_id__volatile;
}


gpointer js_render_node_ref (gpointer instance) {
	JsRenderNode* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void js_render_node_unref (gpointer instance) {
	JsRenderNode* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		JS_RENDER_NODE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



